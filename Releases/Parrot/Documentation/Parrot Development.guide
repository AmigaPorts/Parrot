@DATABASE
@TOC TOC

@NODE MAIN "Parrot Development Guide"
@{FG None}@{BG None}@{b}@{u}@{i}Parrot Development Guide@{uu}@{ub}@{ui}@{BG Background}@{FG Text}


@{FG None}@{BG None}@{u}@{i}Squawk@{uu}@{ui}@{BG Background}@{FG Text}

@{"Introduction" LINK SQUAWK}
@{"Layout" LINK SQUAWKLAYOUT}


@{FG None}@{BG None}@{u}@{i}Assets@{uu}@{ui}@{BG Background}@{FG Text}

@{"Game Info" LINK CT_GAMEINFO}
@{"Asset Table" LINK CT_TABLE}
@{"Asset Table Item" LINK CT_TABLE}


@{FG None}@{BG None}@{u}@{i}Scripting@{uu}@{ui}@{BG Background}@{FG Text}

@{"Virtual Machine" LINK VM}
@{"Opcodes" LINK OPCODES}


@{FG None}@{BG None}@{u}@{i}Reference@{uu}@{ui}@{BG Background}@{FG Text}

@{"Terminology" LINK TERMINOLOGY}
@{"Type Notation" LINK TYPENOTATION}

@ENDNODE

@NODE TOC "Table of Contents"
@{b}@{u}Table of Contents@{uu}@{ub}

@{b}G@{ub}

  @{"Game Info Asset" LINK CT_GAMEINFO}
@{b}P@{ub}

  @{"Parrot Development Guide" LINK MAIN}
@{b}S@{ub}

  @{"Squawk" LINK SQUAWK}
  @{"Squawk File Layout" LINK SQUAWKLAYOUT}
@{b}T@{ub}

  @{"Table Asset" LINK CT_TABLE}
  @{"Terminology" LINK TERMINOLOGY}
  @{"Type Notation" LINK TYPENOTATION}
@{b}V@{ub}

  @{"Virtual Machine" LINK VM}
  @{"Virtual Machine Opcodes" LINK OPCODES}
@ENDNODE

@NODE CT_GAMEINFO "Game Info Asset"
@{FG None}@{BG None}@{b}@{u}@{i}Game Info Asset (GAME_INFO)@{uu}@{ub}@{ui}@{BG Background}@{FG Text}

Design Version
  1.0
Code Version
  1.0

Game Information Table


@{FG None}@{BG None}@{u}@{i}C Version@{uu}@{ui}@{BG Background}@{FG Text}


@{FG Text}@{BG None}  struct GAME_INFO@{BG Background}@{FG Text}
@{FG Text}@{BG None}  {@{BG Background}@{FG Text}
@{FG Text}@{BG None}    ULONG                     gi_GameId;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    ULONG                     gi_GameVersion;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    CHAR                      gi_Title[64];@{BG Background}@{FG Text}
@{FG Text}@{BG None}    CHAR                      gi_ShortTitle[16];@{BG Background}@{FG Text}
@{FG Text}@{BG None}    CHAR                      gi_Author[128];@{BG Background}@{FG Text}
@{FG Text}@{BG None}    CHAR                      gi_Release[128];@{BG Background}@{FG Text}
@{FG Text}@{BG None}    UWORD                     gi_Width;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    UWORD                     gi_Height;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    UWORD                     gi_Depth;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    UWORD                     gi_RoomCount;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    struct OBJECT_TABLE_REF   gi_StartTables[16];@{BG Background}@{FG Text}
@{FG Text}@{BG None}    UWORD                     gi_StartPalette;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    UWORD                     gi_StartCursorPalette;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    UWORD                     gi_StartRoom;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    UWORD                     gi_StartScript;@{BG Background}@{FG Text}
@{FG Text}@{BG None}  };@{BG Background}@{FG Text}

@{FG None}@{BG None}@{u}@{i}gi_GameId (ULONG)@{uu}@{ui}@{BG Background}@{FG Text}


FourCC id of the Game

example:
  PRRT


@{FG None}@{BG None}@{u}@{i}gi_GameVersion (ULONG)@{uu}@{ui}@{BG Background}@{FG Text}

Numerical version of the game.

example:
  0x100


@{FG None}@{BG None}@{u}@{i}gi_Title (CHAR[64])@{uu}@{ui}@{BG Background}@{FG Text}

English title of the Game

example:
  "Adventures of Parrot"


@{FG None}@{BG None}@{u}@{i}gi_ShortTitle (CHAR[16])@{uu}@{ui}@{BG Background}@{FG Text}

English short-hand title of the Game

example:
  "Parrot"


@{FG None}@{BG None}@{u}@{i}gi_Author (CHAR[128])@{uu}@{ui}@{BG Background}@{FG Text}

Full legal text of the Author and/or Publisher of the Game

example:
  "An Adventure Game Company And Associates"


@{FG None}@{BG None}@{u}@{i}gi_Release (CHAR[128])@{uu}@{ui}@{BG Background}@{FG Text}

Release information, including version number and/or Language

example: "Adventures of Parrot 1.0, English"


@{FG None}@{BG None}@{u}@{i}gi_Width (UWORD)@{uu}@{ui}@{BG Background}@{FG Text}

Number of pixels that represent the width of the display

example:
  320


@{FG None}@{BG None}@{u}@{i}gi_Height (UWORD)@{uu}@{ui}@{BG Background}@{FG Text}

Number of pixels that represent the height of the display

example:
  200


@{FG None}@{BG None}@{u}@{i}gi_Depth (UWORD)@{uu}@{ui}@{BG Background}@{FG Text}

Maximum Bitplane depth used by the display

example:
  4


@{FG None}@{BG None}@{u}@{i}gi_RoomCount (UWORD)@{uu}@{ui}@{BG Background}@{FG Text}

Number of Rooms used in this game

example:
  24


@{FG None}@{BG None}@{u}@{i}gi_StartTables (UWORD)@{uu}@{ui}@{BG Background}@{FG Text}

UNDOCUMENTATED


@{FG None}@{BG None}@{u}@{i}gi_StartPalette (UWORD)@{uu}@{ui}@{BG Background}@{FG Text}

Palette Asset ID for the initial Display Palette

example:
  1


@{FG None}@{BG None}@{u}@{i}gi_StartCursorPalette (UWORD)@{uu}@{ui}@{BG Background}@{FG Text}

Palette Asset ID for the initial Cursor Palette

example:
  1


@{FG None}@{BG None}@{u}@{i}gi_StartRoom (UWORD)@{uu}@{ui}@{BG Background}@{FG Text}

UNDOCUMENTATED


@{FG None}@{BG None}@{u}@{i}gi_StartScript (UWORD)@{uu}@{ui}@{BG Background}@{FG Text}

Script Asset ID for the first script to be executed when the game has initialised

example:
  1

@ENDNODE

@NODE CT_TABLE "Table Asset"
@{FG None}@{BG None}@{b}@{u}@{i}Table Asset (ASSET_TABLE)@{uu}@{ub}@{ui}@{BG Background}@{FG Text}

Design Version
  2.0
Code Version
  1.0

Asset Lookup Table


@{FG None}@{BG None}@{u}@{i}C Version@{uu}@{ui}@{BG Background}@{FG Text}


@{FG Text}@{BG None}  struct ASSET_TABLE@{BG Background}@{FG Text}
@{FG Text}@{BG None}  {@{BG Background}@{FG Text}
@{FG Text}@{BG None}    ULONG   at_Type;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    UWORD   at_Chapter;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    UWORD   at_Count;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    UWORD   at_Lowest;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    UWORD   at_Highest;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    +       ITEMS@{BG Background}@{FG Text}
@{FG Text}@{BG None}  };@{BG Background}@{FG Text}

@{FG Text}@{BG None}  struct ASSET_TABLE_ITEM@{BG Background}@{FG Text}
@{FG Text}@{BG None}  {@{BG Background}@{FG Text}
@{FG Text}@{BG None}    UWORD   ti_Id;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    UWORD   ti_Archive;@{BG Background}@{FG Text}
@{FG Text}@{BG None}  };@{BG Background}@{FG Text}

@{FG None}@{BG None}@{u}@{i}Fields@{uu}@{ui}@{BG Background}@{FG Text}


@{FG None}@{BG None}@{u}at_Type@{uu}@{BG Background}@{FG Text}


FourCC type of the Asset

example:
  'R', 'O', 'O', 'M'


@{FG None}@{BG None}@{u}at_Chapter@{uu}@{BG Background}@{FG Text}

The Chapter that these Assets should be used in or 0 for always loaded.

example:
  1


@{FG None}@{BG None}@{u}at_Count@{uu}@{BG Background}@{FG Text}

Number of Assets in this table

example:
  10


@{FG None}@{BG None}@{u}at_Lowest@{uu}@{BG Background}@{FG Text}

The Lowest Id number in this table

example:
  1


@{FG None}@{BG None}@{u}at_Highest@{uu}@{BG Background}@{FG Text}

example:
  10


@{FG None}@{BG None}@{u}DATA@{uu}@{BG Background}@{FG Text}

An array of ASSET_TABLE_ITEMS which are immediately after the ASSET_TABLE
in memory or disk. 

There should be exactly, at_Count of them. They do not need to be zero-
terminated.

example:
  { 1, 1 }
  { 2, 1 }
  { 3, 2 }
  { 4, 2 }
  { 5, 2 }
  { 6, 3 }
  { 7, 3 }
  { 8, 3 }
  { 9, 3 }
  { 10, 4 }

@ENDNODE

@NODE OPCODES "Virtual Machine Opcodes"
@{FG None}@{BG None}@{b}@{u}@{i}Opcodes@{uu}@{ub}@{ui}@{BG Background}@{FG Text}

@{u}Id@{uu} @{u}Len@{uu}  @{u}Name@{uu}       @{u}Arguments@{uu}                  @{u}Description@{uu}
0  2    stop                                  Stop Script
1  2    rem        user.b                     Remark (Ignored}
2  2    pushb      val.b                      push byte onto stack
3  4    pushw      pad.x, val.w               push word onto stack
4  6    pushl      pad.x, val.l               push long onto stack
5  2    pushs      where.b                    push stack[-where] onto stack
6  2    pop                                   pop stack. value is discarded
7  Reserved
8  2    j          addr.sb                    pc <- pc + addr @{b} 2@{ub}
9  2    jz         addr.sb                    pc <- pc + addr @{b} 2@{ub}
                                              if stack[0] = 0
                                              and pop stack
A  2    jnz        addr.sb                    pc <- pc + addr @{b} 2@{ub}
                                              if stack[0] <> 0
                                              and pop stack twice
B  2    je         addr.sb                    pc <- pc + addr @{b} 2@{ub}
                                              if stack[-1] = stack[0]
                                              and pop stack twice
C  2    jne        addr.sb                    pc <- pc + addr @{b} 2@{ub}
                                              if stack[-1] <> stack[0]
                                              and pop stack twice
D  2    jg         addr.sb                    pc <- pc + addr @{b} 2@{ub}
                                              if stack[-1] > stack[0]
                                              and pop stack twice
E  2    jge        addr.sb                    pc <- pc + addr @{b} 2@{ub}
                                              if stack[-1] >= stack[0]
                                              and pop stack twice
F  2    jl         addr.sb                    pc <- pc + addr @{b} 2@{ub}
                                              if stack[-1] < stack[0]
                                              and pop stack twice
10 2    jle        addr.sb                    pc <- pc + addr @{b} 2@{ub}
                                              if stack[-1] <= stack[0]
                                              and pop stack twice
11 2    load       var.lb                     push vars[var] onto stack
12 2    save       var.lb                     vars[var] = stack[0]
                                              and pop stack
13 2    gload      var.b                      push globals[var] onto stack
14 2    gsave      var.b                      globals[var] = stack[0]
                                              and pop stack
15 Reserved
16 Reserved
17 Reserved
18 Reserved
19 Reserved
1A 2    add                                   t <- stack[-1] + stack[0]
                                              pop stack twice
                                              push t
                                              Stack: -1 = lhs.l
                                              Stack:  0 = rhs.l
1B 2    addq       rhs.sb                     t <- stack[0] + rhs
                                              pop stack
                                              push t
                                              Stack: 0 = left.l
1C 2    sub                                   t <- stack[-1] - stack[0]
                                              pop stack twice
                                              push t
                                              Stack: -1 = lhs.l
                                              Stack:  0 = rhs.l
1D 2    subq       rhs.sb                     t <- stack[-1] - val
                                              pop stack
                                              push t
                                              Stack: 0 = left.l
20 2    room                                  load room[0] (as Room}
                                              pop stack
                                              Stack: 0 = room.a
40 2    audio                                 play stack[0] (as SFX Asset}
                                              pop stack
                                              Stack: 0 = sfx.a
80 2    print                                 print stack[0] (as Dialogue}
                                              at y stack[-1] @{b} 8@{ub}
                                              pop stack twice
                                              Stack: -1 = y.b
                                              Stack:  0 = text.d

@ENDNODE

@NODE SQUAWK "Squawk"
@{FG None}@{BG None}@{b}@{u}@{i}Squawk@{uu}@{ub}@{ui}@{BG Background}@{FG Text}

Squawk files are Amiga IFF files that contain Game data. Usually there
are a number of Squark files that make up a Game.

As a general rule, Squark files are numbered 0 to 255 with the "parrot"
file extension.

The 0.parrot file is the master table, which contains essential game 
information, asset lookup tables, palettes, some essential scripts and
image and sound data. It is loaded at all times, and their contents 
loaded as assets within memory at game initialisation.

The 1+ parrot files typically represent a single room, with the 
necessary scripts, image, sound, entity and actor data that is 
typically in a room. This data may be loaded, or partially loaded based
on the game state.

Squawk files are also referred to as Archives within the C code.

@ENDNODE

@NODE SQUAWKLAYOUT "Squawk File Layout"
@{FG None}@{BG None}@{b}@{u}@{i}Squawk File Layout@{uu}@{ub}@{ui}@{BG Background}@{FG Text}


@{FG None}@{BG None}@{u}@{i}File Revision@{uu}@{ui}@{BG Background}@{FG Text}

Design Version
    2.0

Code Version
    1.0


@{FG None}@{BG None}@{u}@{i}General IFF Layout@{uu}@{ui}@{BG Background}@{FG Text}

LIST      SQWK
  FORM    TABL
    SLUG  Asset Table
      Chunk Header
      Table Data
    SLUG  Asset Table
      Chunk Header
      Table Data
    SLUG  Asset Table
      Chunk Header
      Table Data
  FORM    ROOM
    SLUG  Room
      Chunk Header
      Room Data
    SLUG  Room
      Chunk Header
      Room Data
  FORM    SCRIPT
    SLUG  SCRIPT
      Chunk Header
      Script Data
    SLUG  SCRIPT
      Chunk Header
      Script Data
  ...


@{FG None}@{BG None}@{u}Slugs@{uu}@{BG Background}@{FG Text}

A slug is the asset ID encoded as a 4-byte word via the UWordToId
function, and placed within the IFF Chunk Type:-


@{FG Text}@{BG None}    ULONG   Chunk Type@{BG Background}@{FG Text}
@{FG Text}@{BG None}    ULONG   Length@{BG Background}@{FG Text}

It takes each nibble of the UWORD and places for each byte in the
integer in little-endian order. Each byte is then added by a constant
of 0x41 to make the number compatible with FourCC. 


@{FG Text}@{BG None}    ULONG s;@{BG Background}@{FG Text}

@{FG Text}@{BG None}    s = 0x41;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    s += (r & 0xF);@{BG Background}@{FG Text}
@{FG Text}@{BG None}    s <<= 8;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    r >>= 4;@{BG Background}@{FG Text}

@{FG Text}@{BG None}    s += 0x41;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    s += (r & 0xF);@{BG Background}@{FG Text}
@{FG Text}@{BG None}    s <<= 8;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    r >>= 4;@{BG Background}@{FG Text}

@{FG Text}@{BG None}    s += 0x41;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    s += (r & 0xF);@{BG Background}@{FG Text}
@{FG Text}@{BG None}    s <<= 8;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    r >>= 4;@{BG Background}@{FG Text}

@{FG Text}@{BG None}    s += 0x41;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    s += (r & 0xF);@{BG Background}@{FG Text}

@{FG Text}@{BG None}    return s;@{BG Background}@{FG Text}

A ID with 0, is written as AAAA, an ID with 1 is BAAA, and so on.

Although this is against the intentions of the IFF specification, 
it does not give an alternate method for searching through chunks 
without inspecting the data. As the type of data is held within 
the parent chunk, then it provides a quick and easy way of 
iteration without inspecting or knowing how the asset data is 
stored.


@{FG None}@{BG None}@{u}Chunk Header@{uu}@{BG Background}@{FG Text}

Chunk Data is a four byte table placed after the IFF Chunk Header
but before any of the Asset Data.


@{FG Text}@{BG None}  struct CHUNK_HEADER@{BG Background}@{FG Text}
@{FG Text}@{BG None}  {@{BG Background}@{FG Text}
@{FG Text}@{BG None}    UWORD ch_Id;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    UWORD ch_Flags;@{BG Background}@{FG Text}
@{FG Text}@{BG None}  };@{BG Background}@{FG Text}

@{FG None}@{BG None}Chunk Id@{BG Background}@{FG Text}


The Id is a UWORD start starts from 1 to 65535. This is a repeat
of the IFF Chunk ID, but in its original form.


@{FG None}@{BG None}Chunk Flags@{BG Background}@{FG Text}

ch_Flags are populated by the CHUNK_FLAGS enum, these can be the
following values:

Bit 0:  Asset is for the ECS Arch
Bit 1:  Asset is for the AGA Arch
Bit 2:  Asset is for the RTS Arch
Bit 13: Asset may be larger than the Chunk Type specifies, this may be
        due to a sub-type like Entities, or it has dynamic data - such
        as a Script.
Bit 14: Asset has some extra data appended at the end of the asset 
        which requires a special function to load and unload the data.
        This is specified by the CHUNK_FACTORY of that type. Not to be
        confused with Bit 13.
Bit 15: This asset should be ignored and not loaded.

Note:

Bits 0,1,2 May be OR'd together to represent that the asset can be
           loaded regardless of architecture, and this is recommended
           practise for assets that are not backdrops, images or audio
           data.


@{FG None}@{BG None}@{u}Asset Data@{uu}@{BG Background}@{FG Text}

The Data is stored after the Chunk Header. These may be:

- @{"Game Info" LINK ct_gameinfo}
- @{"Table" LINK ct_table}

@ENDNODE

@NODE TERMINOLOGY "Terminology"
@{FG None}@{BG None}@{b}@{u}@{i}Terminology@{uu}@{ub}@{ui}@{BG Background}@{FG Text}


@{FG None}@{BG None}@{u}@{i}A@{uu}@{ui}@{BG Background}@{FG Text}


@{FG None}@{BG None}@{u}Actor@{uu}@{BG Background}@{FG Text}

A Person, Robot, Electronic Device or otherwise movable or immovable 
interactive character that is part of the story.

See @{"Actor (Asset}](CT_ACTOR}, Asset


@{FG None}@{BG None}@{u}Asset@{uu}@{BG Background}@{FG Text}

A saved resource, such as GameInfo, Tables, Room, Actors, Backdrops.

See Actor, Backdrop,


@{FG None}@{BG None}@{u}@{i}B@{uu}@{ui}@{BG Background}@{FG Text}


@{FG None}@{BG None}@{u}Backdrop@{uu}@{BG Background}@{FG Text}

A image that is shown last during a Room. It is non-interactive,
and can be bigger than the display size.


@{FG None}@{BG None}@{u}@{i}C@{uu}@{ui}@{BG Background}@{FG Text}


@{FG None}@{BG None}@{u}@{i}Chapter@{uu}@{ui}@{BG Background}@{FG Text}

A collection of assets; rooms, scripts, actors, images, sounds, etc.
which make up a fragment of an entire story. The only exception is
the global chapter "0" where assets are always available and shared
between other chapters.

Chapters are numbered from 0 to 255.


@{FG None}@{BG None}@{u}@{i}G@{uu}@{ui}@{BG Background}@{FG Text}


@{FG None}@{BG None}@{u}Game Info@{uu}@{BG Background}@{FG Text}

A asset containing the initialisation and meta data about a Game.

See @{"GameInfo (Asset}](CT_GAMEINFO}, Asset

@ENDNODE

@NODE TYPENOTATION "Type Notation"
@{FG None}@{BG None}@{b}@{u}@{i}Type Notation@{uu}@{ub}@{ui}@{BG Background}@{FG Text}


@{FG None}@{BG None}@{u}@{i}Names@{uu}@{ui}@{BG Background}@{FG Text}

Byte
  8 bit unsigned integer
Character, Char
  8 bit unsigned integer representing a single text ASCII character.
Word, Short
  16 bit signed integer
UWord, UShort
  16 bit unsigned integer
Long, Int
  32 bit signed integer
ULong, UInt
  32 bit unsigned integer
APtr
  32 bit untyped pointer
Asset Type
  4 byte non-null terminating string indicating the type of asset 
  data. Usually expressed as as a ulong.
Asset Id
  2 byte identifier. used with asset type and arch flags to 
  identify an asset.
Chunk Header
  4 byte struct containing the id of an asset, and specific 
  loading flags
Asset Header
  8 byte struct containing the Asset Type and Chunk header
Language Id
  4 byte identifier where bits 16-24 represent the Room ID, and 
  the lower 16-bits represents the language text id. Language text 
  may be used for dialogue, textual form of events, verb construction
  or user interface labels. Bits 24-32 arent used.


@{FG None}@{BG None}@{u}@{i}Suffixes@{uu}@{ui}@{BG Background}@{FG Text}

.b
  Byte
.sb
  Signed Byte
.w
  Word
.l
  Long
.lb
  Lower nibble of a byte
.hb
  Higher nibble of a byte
.sp
  Signed pointer offset to Script Program Counter. Value is always 
  multiplied by 2 when used.
.a
  Typeless/arch-less asset id - 2 bytes
.r
  Asset Header
.x
  1 byte Padding Unused
.d
  Language Id

@ENDNODE

@NODE VM "Virtual Machine"
@{FG None}@{BG None}@{b}@{u}@{i}VM@{uu}@{ub}@{ui}@{BG Background}@{FG Text}

Stack based virtual machine. Each stack variable is 4 bytes (LONG}.
There are 16 variables and 256 global variables.

Variables may belong to the object or room running with the script.

@ENDNODE
