@DATABASE
@TOC TOC

@NODE MAIN "Parrot Development Guide"
@{FG None}@{BG None}@{b}@{u}@{i}Parrot Development Guide@{uu}@{ub}@{ui}@{BG Background}@{FG Text}


@{FG None}@{BG None}@{u}@{i}Squawk@{uu}@{ui}@{BG Background}@{FG Text}

@{"Introduction" LINK SQUAWK}
@{"Layout" LINK SQUAWKLAYOUT}


@{FG None}@{BG None}@{u}@{i}Assets@{uu}@{ui}@{BG Background}@{FG Text}

@{"Game Info" LINK CT_GAMEINFO}
@{"Asset Table" LINK CT_TABLE}
@{"Asset Table Item" LINK CT_TABLE}
@{"String Table" LINK CT_STRING_TABLE}
@{"Dialogue" LINK DIALOGUE}


@{FG None}@{BG None}@{u}@{i}Scripting@{uu}@{ui}@{BG Background}@{FG Text}

@{"Virtual Machine" LINK VM}
@{"Opcodes" LINK OPCODES}


@{FG None}@{BG None}@{u}@{i}Reference@{uu}@{ui}@{BG Background}@{FG Text}

@{"Versions" LINK VERSION}
@{"Terminology" LINK TERMINOLOGY}
@{"Type Notation" LINK TYPENOTATION}
@{"Coding Style" LINK CODINGSTYLE}

@ENDNODE

@NODE TOC "Table of Contents"
@{b}@{u}Table of Contents@{uu}@{ub}

@{b}C@{ub}

  @{"Coding Style" LINK CODINGSTYLE}
@{b}D@{ub}

  @{"Dialogue" LINK DIALOGUE}
@{b}G@{ub}

  @{"Game Info Asset" LINK CT_GAMEINFO}
@{b}P@{ub}

  @{"Parrot Development Guide" LINK MAIN}
  @{"Parrot Version" LINK VERSION}
@{b}R@{ub}

  @{"Roadmap" LINK ROADMAP}
@{b}S@{ub}

  @{"Squawk" LINK SQUAWK}
  @{"Squawk File Layout" LINK SQUAWKLAYOUT}
  @{"String Table Asset" LINK CT_STRING_TABLE}
@{b}T@{ub}

  @{"Table Asset" LINK CT_TABLE}
  @{"Terminology" LINK TERMINOLOGY}
  @{"Type Notation" LINK TYPENOTATION}
@{b}V@{ub}

  @{"Virtual Machine" LINK VM}
  @{"Virtual Machine Opcodes" LINK OPCODES}
@ENDNODE

@NODE CODINGSTYLE "Coding Style"
@{FG None}@{BG None}@{b}@{u}@{i}Coding Style@{uu}@{ub}@{ui}@{BG Background}@{FG Text}

Parrot is written in C and is compiled by the VBCC compiler.


@{FG None}@{BG None}@{u}@{i}Braces@{uu}@{ui}@{BG Background}@{FG Text}

Seperate lines


@{FG Text}@{BG None}  if (x == 2)@{BG Background}@{FG Text}
@{FG Text}@{BG None}  {@{BG Background}@{FG Text}
@{FG Text}@{BG None}    /* Action */@{BG Background}@{FG Text}
@{FG Text}@{BG None}  }@{BG Background}@{FG Text}

@{FG None}@{BG None}@{u}@{i}Comments@{uu}@{ui}@{BG Background}@{FG Text}


@{FG Text}@{BG None}  /* Always this */@{BG Background}@{FG Text}
@{FG Text}@{BG None}  // Never this@{BG Background}@{FG Text}

@{FG None}@{BG None}@{u}@{i}Structs@{uu}@{ui}@{BG Background}@{FG Text}


Structures are always referred to "struct Name" never
"Name" through a typedef.

Fields of the structure taken on a prefix of the name
of the structure.


@{FG Text}@{BG None}  struct Lever@{BG Background}@{FG Text}
@{FG Text}@{BG None}  {@{BG Background}@{FG Text}
@{FG Text}@{BG None}    ULONG lv_Strength;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    ULONG lv_Length;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    BOOL  lv_IsDown;@{BG Background}@{FG Text}
@{FG Text}@{BG None}  };@{BG Background}@{FG Text}

@{FG None}@{BG None}@{u}@{i}Functions@{uu}@{ui}@{BG Background}@{FG Text}


Although there is no strict rule with this;

Functions that deal with utilities or extending C code, it should 
use the SubjectAction naming


@{FG Text}@{BG None}  StrLength@{BG Background}@{FG Text}
@{FG Text}@{BG None}  GfxText@{BG Background}@{FG Text}
@{FG Text}@{BG None}  ScriptsInitialise@{BG Background}@{FG Text}

Anything that is more to do with gameplay then:


@{FG Text}@{BG None}  PlayRoom@{BG Background}@{FG Text}
@{FG Text}@{BG None}  LoadAsset@{BG Background}@{FG Text}
@{FG Text}@{BG None}  NewObject@{BG Background}@{FG Text}

@{FG None}@{BG None}@{u}@{i}Naming@{uu}@{ui}@{BG Background}@{FG Text}


Functions and Classes are always in TitleCase


@{FG Text}@{BG None}  PlayRoom@{BG Background}@{FG Text}

@{FG Text}@{BG None}  struct Room;@{BG Background}@{FG Text}

Parameters are always in camelCase


@{FG Text}@{BG None}  roomNum@{BG Background}@{FG Text}

Fields always start with lowercase prefix
then TitleCase


@{FG Text}@{BG None}  rm_Width@{BG Background}@{FG Text}

@{FG None}@{BG None}@{u}@{i}Enums@{uu}@{ui}@{BG Background}@{FG Text}


Enumerations should be defined as pre-processor Macros as 
UPPER_UNDERSCORE case.


@{FG Text}@{BG None}  #define ETF_IS_NAMED  (1 << 0)@{BG Background}@{FG Text}
@{FG Text}@{BG None}  #define ETF_IS_LOCKED (1 << 14)@{BG Background}@{FG Text}
@{FG Text}@{BG None}  #define ETF_IS_OPEN   (1 << 15)@{BG Background}@{FG Text}

Where the first word is an abbreviation of the subject and
the following words are the name.

They should be placed near the first use of them in a 
structure or function.


@{FG None}@{BG None}@{u}@{i}Includes and Headers@{uu}@{ui}@{BG Background}@{FG Text}

With Parrot.h being the exception

Headers should not include other headers, including Parrot.h

Headers should only contain


@{FG Text}@{BG None}  Function Prototypes@{BG Background}@{FG Text}
@{FG Text}@{BG None}  Struct Prototypes@{BG Background}@{FG Text}
@{FG Text}@{BG None}  Enums@{BG Background}@{FG Text}
@{FG Text}@{BG None}  IFF or Node IDs@{BG Background}@{FG Text}

Public structures should be placed in Parrot.h

As Headers are only used .c files, Headers do not need #ifndef
#define #endif Guards.

When using Parrot includes must be in the form of


@{FG Text}@{BG None}  #include <Parrot/Xyz.h>@{BG Background}@{FG Text}

When using Amiga OS includes they must be in the form of


@{FG Text}@{BG None}  #include <exec/types.h>@{BG Background}@{FG Text}

@{FG None}@{BG None}@{u}@{i}Types@{uu}@{ui}@{BG Background}@{FG Text}


Parrot uses the types from <exec/types.h> as its POD types.

These are:-


@{FG Text}@{BG None}  UBYTE   Unsigned  8-bit Integer@{BG Background}@{FG Text}
@{FG Text}@{BG None}  BYTE    Signed    8-bit Integer@{BG Background}@{FG Text}
@{FG Text}@{BG None}  UWORD   Unsigned  16-bit Integer@{BG Background}@{FG Text}
@{FG Text}@{BG None}  WORD    Signed    16-bit Integer@{BG Background}@{FG Text}
@{FG Text}@{BG None}  ULONG   Unsigned  32-bit Integer@{BG Background}@{FG Text}
@{FG Text}@{BG None}  LONG    Signed    32-bit Integer@{BG Background}@{FG Text}

@{FG Text}@{BG None}  VOID    void@{BG Background}@{FG Text}
@{FG Text}@{BG None}  APTR    void*@{BG Background}@{FG Text}
@{FG Text}@{BG None}  BOOL    Boolean@{BG Background}@{FG Text}
@{FG Text}@{BG None}  STRPTR  char*@{BG Background}@{FG Text}

@{FG None}@{BG None}@{u}@{i}Other Macros@{uu}@{ui}@{BG Background}@{FG Text}


Other Macros should be used as well:


@{FG Text}@{BG None}  EXTERN instead of extern@{BG Background}@{FG Text}
@{FG Text}@{BG None}  CONST  instead of const@{BG Background}@{FG Text}
@{FG Text}@{BG None}  STATIC instead of static@{BG Background}@{FG Text}
@{FG Text}@{BG None}  VOID   instead of void@{BG Background}@{FG Text}

@{FG Text}@{BG None}  These are defined in <exec/types.h> and <parrot/Parrot.h>@{BG Background}@{FG Text}
@ENDNODE

@NODE CT_GAMEINFO "Game Info Asset"
@{FG None}@{BG None}@{b}@{u}@{i}Game Info Asset (GAME_INFO)@{uu}@{ub}@{ui}@{BG Background}@{FG Text}

Design Version
  1.0
Code Version
  1.0

Game Information Table


@{FG None}@{BG None}@{u}@{i}C Version@{uu}@{ui}@{BG Background}@{FG Text}


@{FG Text}@{BG None}  struct GAME_INFO@{BG Background}@{FG Text}
@{FG Text}@{BG None}  {@{BG Background}@{FG Text}
@{FG Text}@{BG None}    struct GAME_VERSION       gi_Version;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    ULONG                     gi_FeatureSet;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    ULONG                     gi_GameId;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    ULONG                     gi_GameVersion;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    union DIALOGUE            gi_Title;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    union DIALOGUE            gi_ShortTitle;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    union DIALOGUE            gi_Author;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    union DIALOGUE            gi_Release;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    UWORD                     gi_Width;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    UWORD                     gi_Height;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    UWORD                     gi_Depth;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    UWORD                     gi_RoomCount;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    struct OBJECT_TABLE_REF   gi_StartTables[16];@{BG Background}@{FG Text}
@{FG Text}@{BG None}    UWORD                     gi_StartPalette;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    UWORD                     gi_StartCursorPalette;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    UWORD                     gi_StartRoom;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    UWORD                     gi_StartScript;@{BG Background}@{FG Text}
@{FG Text}@{BG None}  };@{BG Background}@{FG Text}

@{FG None}@{BG None}@{u}@{i}gi_ParrotVersion (struct GAME_VERSION)@{uu}@{ui}@{BG Background}@{FG Text}


The version of Parrot which was used to create the Game Asset files.

example:
  1, 2, 199


@{FG None}@{BG None}@{u}@{i}gi_FeatureSet (ULONG)@{uu}@{ui}@{BG Background}@{FG Text}

A bit-field containg special features required by Parrot to run.

RESERVED FOR FUTURE USE


@{FG None}@{BG None}@{u}@{i}gi_GameId (ULONG)@{uu}@{ui}@{BG Background}@{FG Text}

FourCC id of the Game

example:
  PRRT


@{FG None}@{BG None}@{u}@{i}gi_GameVersion (ULONG)@{uu}@{ui}@{BG Background}@{FG Text}

Numerical version of the game.

example:
  0x100


@{FG None}@{BG None}@{u}@{i}gi_Title (CHAR[64])@{uu}@{ui}@{BG Background}@{FG Text}

English title of the Game

example:
  "Adventures of Parrot"


@{FG None}@{BG None}@{u}@{i}gi_ShortTitle (CHAR[16])@{uu}@{ui}@{BG Background}@{FG Text}

English short-hand title of the Game

example:
  "Parrot"


@{FG None}@{BG None}@{u}@{i}gi_Author (CHAR[128])@{uu}@{ui}@{BG Background}@{FG Text}

Full legal text of the Author and/or Publisher of the Game

example:
  "An Adventure Game Company And Associates"


@{FG None}@{BG None}@{u}@{i}gi_Release (CHAR[128])@{uu}@{ui}@{BG Background}@{FG Text}

Release information, including version number and/or Language

example: "Adventures of Parrot 1.0, English"


@{FG None}@{BG None}@{u}@{i}gi_Width (UWORD)@{uu}@{ui}@{BG Background}@{FG Text}

Number of pixels that represent the width of the display

example:
  320


@{FG None}@{BG None}@{u}@{i}gi_Height (UWORD)@{uu}@{ui}@{BG Background}@{FG Text}

Number of pixels that represent the height of the display

example:
  200


@{FG None}@{BG None}@{u}@{i}gi_Depth (UWORD)@{uu}@{ui}@{BG Background}@{FG Text}

Maximum Bitplane depth used by the display

example:
  4


@{FG None}@{BG None}@{u}@{i}gi_RoomCount (UWORD)@{uu}@{ui}@{BG Background}@{FG Text}

Number of Rooms used in this game

example:
  24


@{FG None}@{BG None}@{u}@{i}gi_StartTables (UWORD)@{uu}@{ui}@{BG Background}@{FG Text}

UNDOCUMENTATED


@{FG None}@{BG None}@{u}@{i}gi_StartPalette (UWORD)@{uu}@{ui}@{BG Background}@{FG Text}

Palette Asset ID for the initial Display Palette

example:
  1


@{FG None}@{BG None}@{u}@{i}gi_StartCursorPalette (UWORD)@{uu}@{ui}@{BG Background}@{FG Text}

Palette Asset ID for the initial Cursor Palette

example:
  1


@{FG None}@{BG None}@{u}@{i}gi_StartRoom (UWORD)@{uu}@{ui}@{BG Background}@{FG Text}

UNDOCUMENTATED


@{FG None}@{BG None}@{u}@{i}gi_StartScript (UWORD)@{uu}@{ui}@{BG Background}@{FG Text}

Script Asset ID for the first script to be executed when the game has initialised

example:
  1

@ENDNODE

@NODE CT_STRING_TABLE "String Table Asset"
@{FG None}@{BG None}@{b}@{u}@{i}Strings Asset (STRING_TABLE)@{uu}@{ub}@{ui}@{BG Background}@{FG Text}

Design Version
  1.0
Code Version
  1.0

Asset Lookup Table


@{FG None}@{BG None}@{u}@{i}C Version@{uu}@{ui}@{BG Background}@{FG Text}


@{FG Text}@{BG None}  struct STRING_TABLE@{BG Background}@{FG Text}
@{FG Text}@{BG None}  {@{BG Background}@{FG Text}
@{FG Text}@{BG None}    UWORD          st_Language;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    UWORD          st_Offsets[256];@{BG Background}@{FG Text}
@{FG Text}@{BG None}    CHAR           st_Text[] /* Upto 66,048 bytes */@{BG Background}@{FG Text}
@{FG Text}@{BG None}  };@{BG Background}@{FG Text}

@{FG None}@{BG None}@{u}@{i}Asset Id@{uu}@{ui}@{BG Background}@{FG Text}


Due to the @{"Dialogue Ref" LINK DIALOGUE} only reserving 1 byte for a the
table Id. The maximum number of STRING Tables is 255. Where 0 is
reserved for None.

In future versions Parrot this may increase to 512.


@{FG None}@{BG None}@{u}@{i}Fields@{uu}@{ui}@{BG Background}@{FG Text}


@{FG None}@{BG None}@{u}st_Language@{uu}@{BG Background}@{FG Text}

Two character ISO 639-1 language code represented as a UWORD

XX is reserved for non-spoke dialogue; such as action text.


@{FG None}@{BG None}@{u}st_Count@{uu}@{BG Background}@{FG Text}

Number of strings + 1 stored in this table. (Upto 256}


@{FG None}@{BG None}@{u}st_Offsets@{uu}@{BG Background}@{FG Text}

Offset of where the string starts from when the STRING_TABLE ends.


@{FG None}@{BG None}@{u}@{i}Strings@{uu}@{ui}@{BG Background}@{FG Text}

Strings are null-terminated strings, with length, null terminators and an
optional pad byte.

For example, for the string "DON'T BE A TUNA HEAD!"



@{FG Text}@{BG None}  15 44 4F 4E 27 54 20 42 45 20 41 20 54 55 4E 41 20 48 45 41 44 21 00 00@{BG Background}@{FG Text}

@{FG Text}@{BG None}  .  D  O  N  '  T     B  E     A     T  U  N  A     H  E  A  D  !  .  .@{BG Background}@{FG Text}

@{FG Text}@{BG None}  .                                                                 .  .@{BG Background}@{FG Text}

@{FG Text}@{BG None}  ._ Length of 21 characters (not including null and pad)           .  .@{BG Background}@{FG Text}

@{FG Text}@{BG None}                                                    Null terminator_.  .@{BG Background}@{FG Text}

@{FG Text}@{BG None}                                                                       .@{BG Background}@{FG Text}

@{FG Text}@{BG None}                                                             Pad byte _.@{BG Background}@{FG Text}

For alignment purposes a total string content, including length and null
terminator must be divisible by 2. If it is not then an extra pad byte is
appended after the null terminator. This is not included in the length.

A length byte is placed at the begining of the string, from 1 to 255.

A null terminator is placed at the end of the string but before the pad.

@ENDNODE

@NODE CT_TABLE "Table Asset"
@{FG None}@{BG None}@{b}@{u}@{i}Table Asset (ASSET_TABLE)@{uu}@{ub}@{ui}@{BG Background}@{FG Text}

Design Version
  2.0
Code Version
  1.0

Asset Lookup Table


@{FG None}@{BG None}@{u}@{i}C Version@{uu}@{ui}@{BG Background}@{FG Text}


@{FG Text}@{BG None}  struct ASSET_TABLE@{BG Background}@{FG Text}
@{FG Text}@{BG None}  {@{BG Background}@{FG Text}
@{FG Text}@{BG None}    ULONG   at_AssetType;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    UWORD   at_Chapter;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    UWORD   at_Count;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    UWORD   at_Lowest;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    UWORD   at_Highest;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    +       ITEMS@{BG Background}@{FG Text}
@{FG Text}@{BG None}  };@{BG Background}@{FG Text}

@{FG Text}@{BG None}  struct ASSET_TABLE_ITEM@{BG Background}@{FG Text}
@{FG Text}@{BG None}  {@{BG Background}@{FG Text}
@{FG Text}@{BG None}    UWORD   ti_Id;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    UWORD   ti_Archive;@{BG Background}@{FG Text}
@{FG Text}@{BG None}  };@{BG Background}@{FG Text}

@{FG None}@{BG None}@{u}@{i}Fields@{uu}@{ui}@{BG Background}@{FG Text}


@{FG None}@{BG None}@{u}at_Type@{uu}@{BG Background}@{FG Text}


FourCC type of the Asset

example:
  'R', 'O', 'O', 'M'


@{FG None}@{BG None}@{u}at_Chapter@{uu}@{BG Background}@{FG Text}

The Chapter that these Assets should be used in or 0 for always loaded.

example:
  1


@{FG None}@{BG None}@{u}at_Count@{uu}@{BG Background}@{FG Text}

Number of Assets in this table

example:
  10


@{FG None}@{BG None}@{u}at_Lowest@{uu}@{BG Background}@{FG Text}

The Lowest Id number in this table

example:
  1


@{FG None}@{BG None}@{u}at_Highest@{uu}@{BG Background}@{FG Text}

example:
  10


@{FG None}@{BG None}@{u}DATA@{uu}@{BG Background}@{FG Text}

An array of ASSET_TABLE_ITEMS which are immediately after the ASSET_TABLE
in memory or disk. 

There should be exactly, at_Count of them. They do not need to be zero-
terminated.

example:
  { 1, 1 }
  { 2, 1 }
  { 3, 2 }
  { 4, 2 }
  { 5, 2 }
  { 6, 3 }
  { 7, 3 }
  { 8, 3 }
  { 9, 3 }
  { 10, 4 }

@ENDNODE

@NODE DIALOGUE "Dialogue"
@{FG None}@{BG None}@{b}@{u}@{i}Dialogue@{uu}@{ub}@{ui}@{BG Background}@{FG Text}

Dialogue refers to usually anything written down, such as the following:

- Dialogue between two or more Actors in a scene
- Dialogue between an actor to the player
- Narration dialogue to the player
- Written action events
- User Interface
- Program Help Text

Dialogue is stored in tables of strings @{"String Table" LINK CT_STRING_TABLE}, it
is referenced by a 4 byte Id, which is in two parts.


@{FG Text}@{BG None}  struct DIALOGUE_REF@{BG Background}@{FG Text}
@{FG Text}@{BG None}  {@{BG Background}@{FG Text}
@{FG Text}@{BG None}    UWORD   dt_Magic;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    UBYTE   dt_Table;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    UBYTE   dt_Item;@{BG Background}@{FG Text}
@{FG Text}@{BG None}  };@{BG Background}@{FG Text}

@{FG Text}@{BG None}  Dialogue Text may be referred to as a Big-Endian ULONG or as a @{BG Background}@{FG Text}
@{FG Text}@{BG None}  C DIALOGUE_REF structure.@{BG Background}@{FG Text}

@{FG None}@{BG None}@{u}@{i}As a Reference@{uu}@{ui}@{BG Background}@{FG Text}


It is recommended that common Dialogue is stored in the master archive;
0.parrot. Where as chapter or room dialogue stored in other dedicated
archives.

It should be noted, that individual pieces of dialogue cannot be sourced
from Disk, as it will bring in all of that Dialogue stored in that 
STRING_TABLE at once. So it is recommended to stored Dialogue together
based on story or location to reduce disk and memory usage.

Dialogue Ids are language neutral, as each STRING_TABLE has a ISO-639-1
code in them, so the Dialogue ID for one piece of text is the same
regardless of the language translation

It should be noted that a string may only have 255 characters, so in
some circumstances some of that string may have to be cut in length.


@{FG None}@{BG None}@{u}@{i}As a Pointer@{uu}@{ui}@{BG Background}@{FG Text}

At run-time when a Room, Entity or other type of object that has a
Dialogue Id. Once a table has been loaded, the Dialogue Id may be
turned into a pointer.


@{FG Text}@{BG None}  union DIALOGUE_TEXT@{BG Background}@{FG Text}
@{FG Text}@{BG None}  {@{BG Background}@{FG Text}
@{FG Text}@{BG None}    struct DIALOGUE_REF dt_Parts;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    ULONG               dt_AssetId;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    CHAR*               dt_Str;@{BG Background}@{FG Text}
@{FG Text}@{BG None}  };@{BG Background}@{FG Text}

@{FG None}@{BG None}@{u}@{i}Tables@{uu}@{ui}@{BG Background}@{FG Text}


There can be upto 256 tables of dialogue, consquently a total of 
65,536 lines of dialogue possible.

This may be expanded on in future versions of Parrot by reserving
some of the lower bits of dt_Magic to increase the maximum table
count.


@{FG None}@{BG None}@{u}@{i}Magic@{uu}@{ui}@{BG Background}@{FG Text}

The two magic bytes are the upper-byte of the Table and Item words
these are compile-time constants.


@{FG Text}@{BG None}  dt_Magic = 0x00FC   (As of Parrot 1.2)@{BG Background}@{FG Text}

These constants are are specially chosen to map the DIALOGUE string
pointer to an reserved address range, reserved by the Amiga 
Kickstart.


@{FG Text}@{BG None}  00FC0000@{BG Background}@{FG Text}
@{FG Text}@{BG None}  00FCFFFF            (As of Parrot 1.2)@{BG Background}@{FG Text}

Knowing that the first two bytes of start with dt_Magic it can be 
converted into a pointer with a lookup of the table and string offset 
address.

@ENDNODE

@NODE OPCODES "Virtual Machine Opcodes"
@{FG None}@{BG None}@{b}@{u}@{i}Opcodes@{uu}@{ub}@{ui}@{BG Background}@{FG Text}

@{u}Id@{uu} @{u}Len@{uu}  @{u}Name@{uu}       @{u}Arguments@{uu}                  @{u}Description@{uu}
0  2    stop                                  Stop Script
1  2    rem        user.b                     Remark (Ignored}
2  2    pushb      val.b                      push byte onto stack
3  4    pushw      pad.x, val.w               push word onto stack
4  6    pushl      pad.x, val.l               push long onto stack
5  2    pushs      where.b                    push stack[-where] onto stack
6  2    pop                                   pop stack. value is discarded
7  Reserved
8  2    j          addr.sb                    pc <- pc + addr @{b} 2@{ub}
9  2    jz         addr.sb                    pc <- pc + addr @{b} 2@{ub}
                                              if stack[0] = 0
                                              and pop stack
A  2    jnz        addr.sb                    pc <- pc + addr @{b} 2@{ub}
                                              if stack[0] <> 0
                                              and pop stack twice
B  2    je         addr.sb                    pc <- pc + addr @{b} 2@{ub}
                                              if stack[-1] = stack[0]
                                              and pop stack twice
C  2    jne        addr.sb                    pc <- pc + addr @{b} 2@{ub}
                                              if stack[-1] <> stack[0]
                                              and pop stack twice
D  2    jg         addr.sb                    pc <- pc + addr @{b} 2@{ub}
                                              if stack[-1] > stack[0]
                                              and pop stack twice
E  2    jge        addr.sb                    pc <- pc + addr @{b} 2@{ub}
                                              if stack[-1] >= stack[0]
                                              and pop stack twice
F  2    jl         addr.sb                    pc <- pc + addr @{b} 2@{ub}
                                              if stack[-1] < stack[0]
                                              and pop stack twice
10 2    jle        addr.sb                    pc <- pc + addr @{b} 2@{ub}
                                              if stack[-1] <= stack[0]
                                              and pop stack twice
11 2    load       var.lb                     push vars[var] onto stack
12 2    save       var.lb                     vars[var] = stack[0]
                                              and pop stack
13 2    gload      var.b                      push globals[var] onto stack
14 2    gsave      var.b                      globals[var] = stack[0]
                                              and pop stack
15 Reserved
16 Reserved
17 Reserved
18 Reserved
19 Reserved
1A 2    add                                   t <- stack[-1] + stack[0]
                                              pop stack twice
                                              push t
                                              Stack: -1 = lhs.l
                                              Stack:  0 = rhs.l
1B 2    addq       rhs.sb                     t <- stack[0] + rhs
                                              pop stack
                                              push t
                                              Stack: 0 = left.l
1C 2    sub                                   t <- stack[-1] - stack[0]
                                              pop stack twice
                                              push t
                                              Stack: -1 = lhs.l
                                              Stack:  0 = rhs.l
1D 2    subq       rhs.sb                     t <- stack[-1] - val
                                              pop stack
                                              push t
                                              Stack: 0 = left.l
20 2    room                                  load room[0] (as Room}
                                              pop stack
                                              Stack: 0 = room.a
40 2    audio                                 play stack[0] (as SFX Asset}
                                              pop stack
                                              Stack: 0 = sfx.a
80 2    print                                 print stack[0] (as Dialogue}
                                              at y stack[-1] @{b} 8@{ub}
                                              pop stack twice
                                              Stack: -1 = y.b
                                              Stack:  0 = text.d

@ENDNODE

@NODE ROADMAP "Roadmap"
@{FG None}@{BG None}@{b}@{u}@{i}Roadmap@{uu}@{ub}@{ui}@{BG Background}@{FG Text}

Parrot is intended to be developed in the following order.

Now


@{FG Text}@{BG None}   1.0.0 Maniac Mansion (1987)@{BG Background}@{FG Text}
@{FG Text}@{BG None}         CBM Amiga Version - Lucasfilms Games@{BG Background}@{FG Text}

@{FG Text}@{BG None}   1.1.0 Data conversion@{BG Background}@{FG Text}
@{FG Text}@{BG None}         Background loading@{BG Background}@{FG Text}
@{FG Text}@{BG None}         Entity Loading@{BG Background}@{FG Text}

@{FG Text}@{BG None}   1.2.0 Large Asset Support and Design@{BG Background}@{FG Text}
@{FG Text}@{BG None}   1.3.0 Script Decompiling and Exit auto-identification.@{BG Background}@{FG Text}
@{FG Text}@{BG None}   1.4.0 Verb Support@{BG Background}@{FG Text}
@{FG Text}@{BG None}   1.5.0 Actors@{BG Background}@{FG Text}
@{FG Text}@{BG None}   1.6.0 Scripting re-visited@{BG Background}@{FG Text}
@{FG Text}@{BG None}   1.7.0 TBD@{BG Background}@{FG Text}

Future


@{FG Text}@{BG None}   2.0.0 Zak McKracken and the Alien Mindbenders (1988)@{BG Background}@{FG Text}
@{FG Text}@{BG None}         CBM Amiga Version - Lucasfilms Games@{BG Background}@{FG Text}
@{FG Text}@{BG None}   3.0.0 Indiana Jones and the Last Crusade (1989)@{BG Background}@{FG Text}
@{FG Text}@{BG None}         CBM Amiga Version - Lucasfilms Games@{BG Background}@{FG Text}
@{FG Text}@{BG None}   4.0.0 Loom (1990)@{BG Background}@{FG Text}
@{FG Text}@{BG None}         CBM Amiga Version - Lucasfilms Games@{BG Background}@{FG Text}
@{FG Text}@{BG None}   5.0.0 The Secret of Monkey Island (1990)@{BG Background}@{FG Text}
@{FG Text}@{BG None}         CBM Amiga Version - Lucasfilms Games@{BG Background}@{FG Text}
@{FG Text}@{BG None}   6.0.0 Monkey Island 2: LeChuck's Revenge (1991)@{BG Background}@{FG Text}
@{FG Text}@{BG None}         CBM Amiga Version - Lucasfilms Games@{BG Background}@{FG Text}
@{FG Text}@{BG None}   7.0.0 Indiana Jones and the Fate of Atlantis (1992)@{BG Background}@{FG Text}
@{FG Text}@{BG None}         CBM Amiga Version - Lucasfilms Games@{BG Background}@{FG Text}
@{FG Text}@{BG None}   8.0.0 Day of the Tentacle (1993)@{BG Background}@{FG Text}
@{FG Text}@{BG None}         PC DOS Version - LucasArts@{BG Background}@{FG Text}
@{FG Text}@{BG None}   9.0.0 Sam & Max Hit the Road (1993)@{BG Background}@{FG Text}
@{FG Text}@{BG None}         PC DOS Version - LucasArts@{BG Background}@{FG Text}
@{FG Text}@{BG None}  10.0.0 Full Throttle (1995)@{BG Background}@{FG Text}
@{FG Text}@{BG None}         PC DOS Version - LucasArts@{BG Background}@{FG Text}
@{FG Text}@{BG None}  11.0.9 The Dig (1995)@{BG Background}@{FG Text}
@{FG Text}@{BG None}         PC DOS Version - LucasArts@{BG Background}@{FG Text}
@{FG Text}@{BG None}  12.0.9 The Curse of Monkey Island (1997)@{BG Background}@{FG Text}
@{FG Text}@{BG None}         MS Windows Version - LucasArts@{BG Background}@{FG Text}
@ENDNODE

@NODE SQUAWK "Squawk"
@{FG None}@{BG None}@{b}@{u}@{i}Squawk@{uu}@{ub}@{ui}@{BG Background}@{FG Text}

Squawk files are Amiga IFF files that contain Game data. Usually there
are a number of Squark files that make up a Game.

As a general rule, Squark files are numbered 0 to 255 with the "parrot"
file extension.

The 0.parrot file is the master table, which contains essential game 
information, asset lookup tables, palettes, some essential scripts and
image and sound data. It is loaded at all times, and their contents 
loaded as assets within memory at game initialisation.

The 1+ parrot files typically represent a single room, with the 
necessary scripts, image, sound, entity and actor data that is 
typically in a room. This data may be loaded, or partially loaded based
on the game state.

Squawk files are also referred to as Archives within the C code.

@ENDNODE

@NODE SQUAWKLAYOUT "Squawk File Layout"
@{FG None}@{BG None}@{b}@{u}@{i}Squawk File Layout@{uu}@{ub}@{ui}@{BG Background}@{FG Text}


@{FG None}@{BG None}@{u}@{i}File Revision@{uu}@{ui}@{BG Background}@{FG Text}

Design Version
    2.0

Code Version
    1.0


@{FG None}@{BG None}@{u}@{i}General IFF Layout@{uu}@{ui}@{BG Background}@{FG Text}

LIST      SQWK
  FORM    TABL
    SLUG  Asset Table
      Asset Header
      Table Data
    SLUG  Asset Table
      Asset Header
      Table Data
    SLUG  Asset Table
      Asset Header
      Table Data
  FORM    ROOM
    SLUG  Room
      Asset Header
      Room Data
    SLUG  Room
      Asset Header
      Room Data
  FORM    SCRIPT
    SLUG  SCRIPT
      Asset Header
      Script Data
    SLUG  SCRIPT
      Asset Header
      Script Data
  ...


@{FG None}@{BG None}@{u}Slugs@{uu}@{BG Background}@{FG Text}

A slug is the asset ID encoded as a 4-byte word via the UWordToId
function, and placed within the IFF Chunk Type:-


@{FG Text}@{BG None}    ULONG   Chunk Type@{BG Background}@{FG Text}
@{FG Text}@{BG None}    ULONG   Length@{BG Background}@{FG Text}

It takes each nibble of the UWORD and places for each byte in the
integer in little-endian order. Each byte is then added by a constant
of 0x41 to make the number compatible with FourCC. 


@{FG Text}@{BG None}    ULONG s;@{BG Background}@{FG Text}

@{FG Text}@{BG None}    s = 0x41;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    s += (r & 0xF);@{BG Background}@{FG Text}
@{FG Text}@{BG None}    s <<= 8;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    r >>= 4;@{BG Background}@{FG Text}

@{FG Text}@{BG None}    s += 0x41;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    s += (r & 0xF);@{BG Background}@{FG Text}
@{FG Text}@{BG None}    s <<= 8;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    r >>= 4;@{BG Background}@{FG Text}

@{FG Text}@{BG None}    s += 0x41;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    s += (r & 0xF);@{BG Background}@{FG Text}
@{FG Text}@{BG None}    s <<= 8;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    r >>= 4;@{BG Background}@{FG Text}

@{FG Text}@{BG None}    s += 0x41;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    s += (r & 0xF);@{BG Background}@{FG Text}

@{FG Text}@{BG None}    return s;@{BG Background}@{FG Text}

A ID with 0, is written as AAAA, an ID with 1 is BAAA, and so on.

Although this is against the intentions of the IFF specification, 
it does not give an alternate method for searching through chunks 
without inspecting the data. As the type of data is held within 
the parent chunk, then it provides a quick and easy way of 
iteration without inspecting or knowing how the asset data is 
stored.


@{FG None}@{BG None}@{u}Asset Header@{uu}@{BG Background}@{FG Text}

The Asset Header is a four byte table placed after the IFF Chunk
Header but before any of the Asset Data.


@{FG Text}@{BG None}  struct ASSET_HEADER@{BG Background}@{FG Text}
@{FG Text}@{BG None}  {@{BG Background}@{FG Text}
@{FG Text}@{BG None}    UWORD ah_Id;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    UWORD ah_AssetFlags;@{BG Background}@{FG Text}
@{FG Text}@{BG None}  };@{BG Background}@{FG Text}

@{FG None}@{BG None}Asset Id@{BG Background}@{FG Text}


The Id is a UWORD start starts from 1 to 65535. This is a repeat
of the Slug in the Chunk Type, but in its original form.


@{FG None}@{BG None}Asset Flags@{BG Background}@{FG Text}

ah_AssetFlags are populated by the CHUNK_FLAGS enum, these can be 
the following values:

Bit 0:  Asset is for the ECS Arch
Bit 1:  Asset is for the AGA Arch
Bit 2:  Asset is for the RTS Arch
Bit 13: Asset may be larger than the Chunk Type specifies, this may be
        due to a sub-type like Entities, or it has dynamic data - such
        as a Script.
Bit 14: Asset has some extra data appended at the end of the asset 
        which requires a special function to load and unload the data.
        This is specified by the CHUNK_FACTORY of that type. Not to be
        confused with Bit 13.
Bit 15: This asset should be ignored and not loaded.

Note:

Bits 0,1,2 May be OR'd together to represent that the asset can be
           loaded regardless of architecture, and this is recommended
           practise for assets that are not backdrops, images or audio
           data.


@{FG None}@{BG None}@{u}Asset Data@{uu}@{BG Background}@{FG Text}

The Data is stored after the Asset Header. These may be:

- @{"Game Info" LINK ct_gameinfo}
- @{"Table" LINK ct_table}

@ENDNODE

@NODE TERMINOLOGY "Terminology"
@{FG None}@{BG None}@{b}@{u}@{i}Terminology@{uu}@{ub}@{ui}@{BG Background}@{FG Text}


@{FG None}@{BG None}@{u}@{i}A@{uu}@{ui}@{BG Background}@{FG Text}


@{FG None}@{BG None}@{u}Actor@{uu}@{BG Background}@{FG Text}

A Person, Robot, Electronic Device or otherwise movable or immovable 
interactive character that is part of the story.

See @{"Actor (Asset}](CT_ACTOR}, Asset


@{FG None}@{BG None}@{u}Asset@{uu}@{BG Background}@{FG Text}

A saved resource, such as GameInfo, Tables, Room, Actors, Backdrops.

See Actor, Backdrop,


@{FG None}@{BG None}@{u}@{i}B@{uu}@{ui}@{BG Background}@{FG Text}


@{FG None}@{BG None}@{u}Backdrop@{uu}@{BG Background}@{FG Text}

A image that is shown last during a Room. It is non-interactive,
and can be bigger than the display size.


@{FG None}@{BG None}@{u}@{i}C@{uu}@{ui}@{BG Background}@{FG Text}


@{FG None}@{BG None}@{u}@{i}Chapter@{uu}@{ui}@{BG Background}@{FG Text}

A collection of assets; rooms, scripts, actors, images, sounds, etc.
which make up a fragment of an entire story. The only exception is
the global chapter "0" where assets are always available and shared
between other chapters.

Chapters are numbered from 0 to 255.


@{FG None}@{BG None}@{u}@{i}G@{uu}@{ui}@{BG Background}@{FG Text}


@{FG None}@{BG None}@{u}Game Info@{uu}@{BG Background}@{FG Text}

A asset containing the initialisation and meta data about a Game.

See @{"GameInfo (Asset}](CT_GAMEINFO}, Asset

@ENDNODE

@NODE TYPENOTATION "Type Notation"
@{FG None}@{BG None}@{b}@{u}@{i}Type Notation@{uu}@{ub}@{ui}@{BG Background}@{FG Text}


@{FG None}@{BG None}@{u}@{i}Names@{uu}@{ui}@{BG Background}@{FG Text}

Byte
  8 bit unsigned integer
Character, Char
  8 bit unsigned integer representing a single text ASCII character.
Word, Short
  16 bit signed integer
UWord, UShort
  16 bit unsigned integer
Long, Int
  32 bit signed integer
ULong, UInt
  32 bit unsigned integer
APtr
  32 bit untyped pointer
Asset Type
  4 byte non-null terminating string indicating the type of asset 
  data. Usually expressed as as a ulong.
Asset Id
  2 byte identifier. used with asset type and arch flags to 
  identify an asset.
Chunk Header
  4 byte struct containing the id of an asset, and specific 
  loading flags
Asset Header
  8 byte struct containing the Asset Type and Chunk header
Language Id
  4 byte identifier where bits 16-24 represent the Room ID, and 
  the lower 16-bits represents the language text id. Language text 
  may be used for dialogue, textual form of events, verb construction
  or user interface labels. Bits 24-32 arent used.


@{FG None}@{BG None}@{u}@{i}Suffixes@{uu}@{ui}@{BG Background}@{FG Text}

.b
  Byte
.sb
  Signed Byte
.w
  Word
.l
  Long
.lb
  Lower nibble of a byte
.hb
  Higher nibble of a byte
.sp
  Signed pointer offset to Script Program Counter. Value is always 
  multiplied by 2 when used.
.a
  Typeless/arch-less asset id - 2 bytes
.r
  Asset Header
.x
  1 byte Padding Unused
.d
  Language Id

@ENDNODE

@NODE VERSION "Parrot Version"
@{FG None}@{BG None}@{b}@{u}@{i}Parrot Version@{uu}@{ub}@{ui}@{BG Background}@{FG Text}

Parrot uses the sematic versioning system where a given 
version number is written as:


@{FG Text}@{BG None}  GAME.FEATURE.BUILD@{BG Background}@{FG Text}


GAME versions correspond to which minimum Game Parrot
supports, these are:-


@{FG Text}@{BG None}   1. Maniac Mansion (1987)@{BG Background}@{FG Text}
@{FG Text}@{BG None}      CBM Amiga Version - Lucasfilms Games@{BG Background}@{FG Text}
@{FG Text}@{BG None}   2. Zak McKracken and the Alien Mindbenders (1988)@{BG Background}@{FG Text}
@{FG Text}@{BG None}      CBM Amiga Version - Lucasfilms Games@{BG Background}@{FG Text}
@{FG Text}@{BG None}   3. Indiana Jones and the Last Crusade (1989)@{BG Background}@{FG Text}
@{FG Text}@{BG None}      CBM Amiga Version - Lucasfilms Games@{BG Background}@{FG Text}
@{FG Text}@{BG None}   4. Loom (1990)@{BG Background}@{FG Text}
@{FG Text}@{BG None}      CBM Amiga Version - Lucasfilms Games@{BG Background}@{FG Text}
@{FG Text}@{BG None}   5. The Secret of Monkey Island (1990)@{BG Background}@{FG Text}
@{FG Text}@{BG None}      CBM Amiga Version - Lucasfilms Games@{BG Background}@{FG Text}
@{FG Text}@{BG None}   6. Monkey Island 2: LeChuck's Revenge (1991)@{BG Background}@{FG Text}
@{FG Text}@{BG None}      CBM Amiga Version - Lucasfilms Games@{BG Background}@{FG Text}
@{FG Text}@{BG None}   7. Indiana Jones and the Fate of Atlantis (1992)@{BG Background}@{FG Text}
@{FG Text}@{BG None}      CBM Amiga Version - Lucasfilms Games@{BG Background}@{FG Text}
@{FG Text}@{BG None}   8. Day of the Tentacle (1993)@{BG Background}@{FG Text}
@{FG Text}@{BG None}      PC DOS Version - LucasArts@{BG Background}@{FG Text}
@{FG Text}@{BG None}   9. Sam & Max Hit the Road (1993)@{BG Background}@{FG Text}
@{FG Text}@{BG None}      PC DOS Version - LucasArts@{BG Background}@{FG Text}
@{FG Text}@{BG None}  10. Full Throttle (1995)@{BG Background}@{FG Text}
@{FG Text}@{BG None}      PC DOS Version - LucasArts@{BG Background}@{FG Text}
@{FG Text}@{BG None}  11. The Dig (1995)@{BG Background}@{FG Text}
@{FG Text}@{BG None}      PC DOS Version - LucasArts@{BG Background}@{FG Text}
@{FG Text}@{BG None}  12. The Curse of Monkey Island (1997)@{BG Background}@{FG Text}
@{FG Text}@{BG None}      MS Windows Version - LucasArts@{BG Background}@{FG Text}

Files saved via older GAME versions are expected 
to be incompatible with newer GAME versions.


@{FG Text}@{BG None}  i.e.  Parrot files saved with version 3.9.3 are@{BG Background}@{FG Text}
@{FG Text}@{BG None}        likely not to work with with Parrot 2.0.1@{BG Background}@{FG Text}

@{FG Text}@{BG None}        However; Parrot 3.9.3, can play Maniac Mansion,@{BG Background}@{FG Text}
@{FG Text}@{BG None}        Zak McKracken and the Alien MindBenders and@{BG Background}@{FG Text}
@{FG Text}@{BG None}        Indiana Jones and the Last Crusade.@{BG Background}@{FG Text}

FEATURE versions are incremented when a feature of
that Game has been totally completed. This is expected
to have backwards compatbile manner.

BUILD versions are incremented when a commit has been
pushed to the Git and Github repository. Although a 
1:1 parity is not expected. BUILD versions are stored
as a two byte integer, and can roll over if the number
of commits reaches 65,535.


@{FG None}@{BG None}@{u}@{i}C Implementation@{uu}@{ui}@{BG Background}@{FG Text}

Internally a VERSION_INFO union is used which is represents
a version number as a C Struct or a ULONG (in Big Endian}


@{FG Text}@{BG None}  union VERSION_INFO@{BG Background}@{FG Text}
@{FG Text}@{BG None}  {@{BG Background}@{FG Text}
@{FG Text}@{BG None}    struct@{BG Background}@{FG Text}
@{FG Text}@{BG None}    {@{BG Background}@{FG Text}
@{FG Text}@{BG None}      UBYTE gv_Game;@{BG Background}@{FG Text}
@{FG Text}@{BG None}      UBYTE gv_Feature;@{BG Background}@{FG Text}
@{FG Text}@{BG None}      UBYTE gv_Build;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    } gv_Version;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    ULONG gv_Num;@{BG Background}@{FG Text}
@{FG Text}@{BG None}  };@{BG Background}@{FG Text}

To determine if a a Version is older or newer, the gv_Num field
can be compared with <, > or == operators.

@ENDNODE

@NODE VM "Virtual Machine"
@{FG None}@{BG None}@{b}@{u}@{i}VM@{uu}@{ub}@{ui}@{BG Background}@{FG Text}

Stack based virtual machine. Each stack variable is 4 bytes (LONG}.
There are 16 variables and 256 global variables.

Variables may belong to the object or room running with the script.

@ENDNODE
