@DATABASE
@TOC TOC

@NODE MAIN "Parrot Development Guide"
@{FG None}@{BG None}@{b}@{u}@{i}Parrot Development Guide@{uu}@{ub}@{ui}@{BG Background}@{FG Text}


@{FG None}@{BG None}@{u}@{i}Squawk@{uu}@{ui}@{BG Background}@{FG Text}

@{"Introduction" LINK SQUAWK}
@{"Layout" LINK SQUAWKLAYOUT}


@{FG None}@{BG None}@{u}@{i}Assets@{uu}@{ui}@{BG Background}@{FG Text}

@{"Game Info" LINK CT_GAMEINFO}
@{"Asset Table" LINK CT_TABLE}
@{"Asset Table Item" LINK CT_TABLE}
@{"String Table" LINK CT_STRING_TABLE}
@{"Dialogue" LINK DIALOGUE}


@{FG None}@{BG None}@{u}@{i}Scripting@{uu}@{ui}@{BG Background}@{FG Text}

@{"Virtual Machine" LINK VM}
@{"Opcodes" LINK OPCODES}


@{FG None}@{BG None}@{u}@{i}Reference@{uu}@{ui}@{BG Background}@{FG Text}

@{"Versions" LINK VERSION}
@{"Terminology" LINK TERMINOLOGY}
@{"Type Notation" LINK TYPENOTATION}
@{"Coding Style" LINK CODINGSTYLE}

@ENDNODE

@NODE TOC "Table of Contents"
@{b}@{u}Table of Contents@{uu}@{ub}

@{b}C@{ub}

  @{"Coding Style" LINK CODINGSTYLE}
@{b}D@{ub}

  @{"Dialogue" LINK DIALOGUE}
@{b}G@{ub}

  @{"Game Info Asset" LINK CT_GAMEINFO}
@{b}O@{ub}

  @{"Opcodes" LINK OPCODES}
@{b}P@{ub}

  @{"Parrot Development Guide" LINK MAIN}
  @{"Parrot Version" LINK VERSION}
@{b}R@{ub}

  @{"Roadmap" LINK ROADMAP}
@{b}S@{ub}

  @{"Squawk" LINK SQUAWK}
  @{"Squawk File Layout" LINK SQUAWKLAYOUT}
  @{"String Table Asset" LINK CT_STRING_TABLE}
@{b}T@{ub}

  @{"Table Asset" LINK CT_TABLE}
  @{"Terminology" LINK TERMINOLOGY}
  @{"Type Notation" LINK TYPENOTATION}
@{b}V@{ub}

  @{"Virtual Machine" LINK VM}
@ENDNODE

@NODE CODINGSTYLE "Coding Style"
@{FG None}@{BG None}@{b}@{u}@{i}Coding Style@{uu}@{ub}@{ui}@{BG Background}@{FG Text}

Parrot is written in C and is compiled by the VBCC compiler.


@{FG None}@{BG None}@{u}@{i}Braces@{uu}@{ui}@{BG Background}@{FG Text}

Seperate lines


@{FG Text}@{BG None}  if (x == 2)@{BG Background}@{FG Text}
@{FG Text}@{BG None}  {@{BG Background}@{FG Text}
@{FG Text}@{BG None}    /* Action */@{BG Background}@{FG Text}
@{FG Text}@{BG None}  }@{BG Background}@{FG Text}

@{FG None}@{BG None}@{u}@{i}Comments@{uu}@{ui}@{BG Background}@{FG Text}


@{FG Text}@{BG None}  /* Always this */@{BG Background}@{FG Text}
@{FG Text}@{BG None}  // Never this@{BG Background}@{FG Text}

@{FG None}@{BG None}@{u}@{i}Structs@{uu}@{ui}@{BG Background}@{FG Text}


Structures are always referred to "struct Name" never
"Name" through a typedef.

Fields of the structure taken on a prefix of the name
of the structure.


@{FG Text}@{BG None}  struct Lever@{BG Background}@{FG Text}
@{FG Text}@{BG None}  {@{BG Background}@{FG Text}
@{FG Text}@{BG None}    PtUnsigned32 lv_Strength;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    PtUnsigned32 lv_Length;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    BOOL  lv_IsDown;@{BG Background}@{FG Text}
@{FG Text}@{BG None}  };@{BG Background}@{FG Text}

@{FG None}@{BG None}@{u}@{i}Functions@{uu}@{ui}@{BG Background}@{FG Text}


Although there is no strict rule with this;

Functions that deal with utilities or extending C code, it should 
use the SubjectAction naming


@{FG Text}@{BG None}  StrLength@{BG Background}@{FG Text}
@{FG Text}@{BG None}  GfxText@{BG Background}@{FG Text}
@{FG Text}@{BG None}  ScriptsInitialise@{BG Background}@{FG Text}

Anything that is more to do with gameplay then:


@{FG Text}@{BG None}  PlayRoom@{BG Background}@{FG Text}
@{FG Text}@{BG None}  LoadAsset@{BG Background}@{FG Text}
@{FG Text}@{BG None}  NewObject@{BG Background}@{FG Text}

@{FG None}@{BG None}@{u}@{i}Naming@{uu}@{ui}@{BG Background}@{FG Text}


Functions and Classes are always in TitleCase


@{FG Text}@{BG None}  PlayRoom@{BG Background}@{FG Text}

@{FG Text}@{BG None}  struct Room;@{BG Background}@{FG Text}

Parameters are always in camelCase


@{FG Text}@{BG None}  roomNum@{BG Background}@{FG Text}

Fields always start with lowercase prefix
then TitleCase


@{FG Text}@{BG None}  rm_Width@{BG Background}@{FG Text}

@{FG None}@{BG None}@{u}@{i}Enums@{uu}@{ui}@{BG Background}@{FG Text}


Enumerations should be defined as pre-processor Macros as 
UPPER_UNDERSCORE case.


@{FG Text}@{BG None}  #define ETF_IS_NAMED  (1 << 0)@{BG Background}@{FG Text}
@{FG Text}@{BG None}  #define ETF_IS_LOCKED (1 << 14)@{BG Background}@{FG Text}
@{FG Text}@{BG None}  #define ETF_IS_OPEN   (1 << 15)@{BG Background}@{FG Text}

Where the first word is an abbreviation of the subject and
the following words are the name.

They should be placed near the first use of them in a 
structure or function.


@{FG None}@{BG None}@{u}@{i}Includes and Headers@{uu}@{ui}@{BG Background}@{FG Text}

With Parrot.h being the exception

Headers should not include other headers, including Parrot.h

Headers should only contain


@{FG Text}@{BG None}  Function Prototypes@{BG Background}@{FG Text}
@{FG Text}@{BG None}  Struct Prototypes@{BG Background}@{FG Text}
@{FG Text}@{BG None}  Enums@{BG Background}@{FG Text}
@{FG Text}@{BG None}  IFF or Node IDs@{BG Background}@{FG Text}

Public structures should be placed in Parrot.h

As Headers are only used .c files, Headers do not need #ifndef
#define #endif Guards.

When using Parrot includes must be in the form of


@{FG Text}@{BG None}  #include <Parrot/Xyz.h>@{BG Background}@{FG Text}

When using Amiga OS includes they must be in the form of


@{FG Text}@{BG None}  #include <exec/types.h>@{BG Background}@{FG Text}

@{FG None}@{BG None}@{u}@{i}Types@{uu}@{ui}@{BG Background}@{FG Text}


Parrot uses the types from <exec/types.h> as its POD types.

These are:-


@{FG Text}@{BG None}  PtUnsigned8   Unsigned  8-bit Integer@{BG Background}@{FG Text}
@{FG Text}@{BG None}  PtByte    Signed    8-bit Integer@{BG Background}@{FG Text}
@{FG Text}@{BG None}  PtUnsigned16   Unsigned  16-bit Integer@{BG Background}@{FG Text}
@{FG Text}@{BG None}  PtSigned16    Signed    16-bit Integer@{BG Background}@{FG Text}
@{FG Text}@{BG None}  PtUnsigned32   Unsigned  32-bit Integer@{BG Background}@{FG Text}
@{FG Text}@{BG None}  PtSigned32    Signed    32-bit Integer@{BG Background}@{FG Text}

@{FG Text}@{BG None}  void    void@{BG Background}@{FG Text}
@{FG Text}@{BG None}  APTR    void*@{BG Background}@{FG Text}
@{FG Text}@{BG None}  BOOL    Boolean@{BG Background}@{FG Text}
@{FG Text}@{BG None}  STRPTR  char*@{BG Background}@{FG Text}

@{FG None}@{BG None}@{u}@{i}Other Macros@{uu}@{ui}@{BG Background}@{FG Text}


Other Macros should be used as well:


@{FG Text}@{BG None}  PtPublic instead of extern@{BG Background}@{FG Text}
@{FG Text}@{BG None}  CONST  instead of const@{BG Background}@{FG Text}
@{FG Text}@{BG None}  STATIC instead of static@{BG Background}@{FG Text}
@{FG Text}@{BG None}  void   instead of void@{BG Background}@{FG Text}

@{FG Text}@{BG None}  These are defined in <exec/types.h> and <parrot/Parrot.h>@{BG Background}@{FG Text}
@ENDNODE

@NODE CT_GAMEINFO "Game Info Asset"
@{FG None}@{BG None}@{b}@{u}@{i}Game Info Asset (GAME_INFO)@{uu}@{ub}@{ui}@{BG Background}@{FG Text}

Design Version
  1.0
Code Version
  1.0

Game Information Table


@{FG None}@{BG None}@{u}@{i}C Version@{uu}@{ui}@{BG Background}@{FG Text}


@{FG Text}@{BG None}  PtGameInfo@{BG Background}@{FG Text}
@{FG Text}@{BG None}  {@{BG Background}@{FG Text}
@{FG Text}@{BG None}    struct GAME_VERSION       gi_Version;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    PtUnsigned32                     gi_FeatureSet;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    PtUnsigned32                     gi_GameId;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    PtUnsigned32                     gi_GameVersion;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    DIALOGUE                  gi_Title;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    DIALOGUE                  gi_ShortTitle;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    DIALOGUE                  gi_Author;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    DIALOGUE                  gi_Release;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    PtUnsigned16                     gi_Width;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    PtUnsigned16                     gi_Height;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    PtUnsigned16                     gi_Depth;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    PtUnsigned16                     gi_RoomCount;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    struct OBJECT_TABLE_REF   gi_StartTables[16];@{BG Background}@{FG Text}
@{FG Text}@{BG None}    PtUnsigned16                     gi_StartPalette;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    PtUnsigned16                     gi_StartCursorPalette;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    PtUnsigned16                     gi_StartRoom;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    PtUnsigned16                     gi_StartScript;@{BG Background}@{FG Text}
@{FG Text}@{BG None}  };@{BG Background}@{FG Text}

@{FG None}@{BG None}@{u}@{i}gi_ParrotVersion (struct GAME_VERSION)@{uu}@{ui}@{BG Background}@{FG Text}


The version of Parrot which was used to create the Game Asset files.

example:
  1, 2, 199


@{FG None}@{BG None}@{u}@{i}gi_FeatureSet (PtUnsigned32)@{uu}@{ui}@{BG Background}@{FG Text}

A bit-field containg special features required by Parrot to run.

RESERVED FOR FUTURE USE


@{FG None}@{BG None}@{u}@{i}gi_GameId (PtUnsigned32)@{uu}@{ui}@{BG Background}@{FG Text}

FourCC id of the Game

example:
  PRRT


@{FG None}@{BG None}@{u}@{i}gi_GameVersion (PtUnsigned32)@{uu}@{ui}@{BG Background}@{FG Text}

Numerical version of the game.

example:
  0x100


@{FG None}@{BG None}@{u}@{i}gi_Title (DIALOGUE)@{uu}@{ui}@{BG Background}@{FG Text}

English title of the Game

example:
  "Adventures of Parrot"


@{FG None}@{BG None}@{u}@{i}gi_ShortTitle (DIALOGUE)@{uu}@{ui}@{BG Background}@{FG Text}

English short-hand title of the Game

example:
  "Parrot"


@{FG None}@{BG None}@{u}@{i}gi_Author (DIALOGUE)@{uu}@{ui}@{BG Background}@{FG Text}

Full legal text of the Author and/or Publisher of the Game

example:
  "An Adventure Game Company And Associates"


@{FG None}@{BG None}@{u}@{i}gi_Release (DIALOGUE)@{uu}@{ui}@{BG Background}@{FG Text}

Release information, including version number and/or Language

example: "Adventures of Parrot 1.0, English"


@{FG None}@{BG None}@{u}@{i}gi_Width (PtUnsigned16)@{uu}@{ui}@{BG Background}@{FG Text}

Number of pixels that represent the width of the display

example:
  320


@{FG None}@{BG None}@{u}@{i}gi_Height (PtUnsigned16)@{uu}@{ui}@{BG Background}@{FG Text}

Number of pixels that represent the height of the display

example:
  200


@{FG None}@{BG None}@{u}@{i}gi_Depth (PtUnsigned16)@{uu}@{ui}@{BG Background}@{FG Text}

Maximum Bitplane depth used by the display

example:
  4


@{FG None}@{BG None}@{u}@{i}gi_RoomCount (PtUnsigned16)@{uu}@{ui}@{BG Background}@{FG Text}

Number of Rooms used in this game

example:
  24


@{FG None}@{BG None}@{u}@{i}gi_StartTables (PtUnsigned16)@{uu}@{ui}@{BG Background}@{FG Text}

UNDOCUMENTATED


@{FG None}@{BG None}@{u}@{i}gi_StartPalette (PtUnsigned16)@{uu}@{ui}@{BG Background}@{FG Text}

Palette Asset ID for the initial Display Palette

example:
  1


@{FG None}@{BG None}@{u}@{i}gi_StartCursorPalette (PtUnsigned16)@{uu}@{ui}@{BG Background}@{FG Text}

Palette Asset ID for the initial Cursor Palette

example:
  1


@{FG None}@{BG None}@{u}@{i}gi_StartRoom (PtUnsigned16)@{uu}@{ui}@{BG Background}@{FG Text}

UNDOCUMENTATED


@{FG None}@{BG None}@{u}@{i}gi_StartScript (PtUnsigned16)@{uu}@{ui}@{BG Background}@{FG Text}

Script Asset ID for the first script to be executed when the game has initialised

example:
  1

@ENDNODE

@NODE CT_STRING_TABLE "String Table Asset"
@{FG None}@{BG None}@{b}@{u}@{i}Strings Asset (STRING_TABLE)@{uu}@{ub}@{ui}@{BG Background}@{FG Text}

Design Version
  1.0
Code Version
  1.0

Asset Lookup Table


@{FG None}@{BG None}@{u}@{i}C Version@{uu}@{ui}@{BG Background}@{FG Text}


@{FG Text}@{BG None}  struct STRING_TABLE@{BG Background}@{FG Text}
@{FG Text}@{BG None}  {@{BG Background}@{FG Text}
@{FG Text}@{BG None}    PtUnsigned16          st_Language;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    PtUnsigned16          st_Offsets[256];@{BG Background}@{FG Text}
@{FG Text}@{BG None}    PtChar           st_Text[] /* Upto 66,048 bytes */@{BG Background}@{FG Text}
@{FG Text}@{BG None}  };@{BG Background}@{FG Text}

@{FG None}@{BG None}@{u}@{i}Asset Id@{uu}@{ui}@{BG Background}@{FG Text}


Due to the @{"Dialogue Ref" LINK DIALOGUE} only reserving 1 byte for a the
table Id. The maximum number of STRING Tables is 255. Where 0 is
reserved for None.

In future versions Parrot this may increase to 512.


@{FG None}@{BG None}@{u}@{i}Fields@{uu}@{ui}@{BG Background}@{FG Text}


@{FG None}@{BG None}@{u}st_Language@{uu}@{BG Background}@{FG Text}

Two character ISO 639-1 language code represented as a PtUnsigned16

XX is reserved for non-spoke dialogue; such as action text.


@{FG None}@{BG None}@{u}st_Count@{uu}@{BG Background}@{FG Text}

Number of strings + 1 stored in this table. (Upto 256}


@{FG None}@{BG None}@{u}st_Offsets@{uu}@{BG Background}@{FG Text}

Offset of where the string starts from when the STRING_TABLE ends.


@{FG None}@{BG None}@{u}@{i}Strings@{uu}@{ui}@{BG Background}@{FG Text}

Strings are null-terminated strings, with length, null terminators and an
optional pad byte.

For example, for the string "DON'T BE A TUNA HEAD!"



@{FG Text}@{BG None}  15 44 4F 4E 27 54 20 42 45 20 41 20 54 55 4E 41 20 48 45 41 44 21 00 00@{BG Background}@{FG Text}

@{FG Text}@{BG None}  .  D  O  N  '  T     B  E     A     T  U  N  A     H  E  A  D  !  .  .@{BG Background}@{FG Text}

@{FG Text}@{BG None}  .                                                                 .  .@{BG Background}@{FG Text}

@{FG Text}@{BG None}  ._ Length of 21 characters (not including null and pad)           .  .@{BG Background}@{FG Text}

@{FG Text}@{BG None}                                                    Null terminator_.  .@{BG Background}@{FG Text}

@{FG Text}@{BG None}                                                                       .@{BG Background}@{FG Text}

@{FG Text}@{BG None}                                                             Pad byte _.@{BG Background}@{FG Text}

For alignment purposes a total string content, including length and null
terminator must be divisible by 2. If it is not then an extra pad byte is
appended after the null terminator. This is not included in the length.

A length byte is placed at the begining of the string, from 1 to 255.

A null terminator is placed at the end of the string but before the pad.

@ENDNODE

@NODE CT_TABLE "Table Asset"
@{FG None}@{BG None}@{b}@{u}@{i}Table Asset (ASSET_TABLE)@{uu}@{ub}@{ui}@{BG Background}@{FG Text}

Design Version
  2.0
Code Version
  1.0

Asset Lookup Table


@{FG None}@{BG None}@{u}@{i}C Version@{uu}@{ui}@{BG Background}@{FG Text}


@{FG Text}@{BG None}  struct ASSET_TABLE@{BG Background}@{FG Text}
@{FG Text}@{BG None}  {@{BG Background}@{FG Text}
@{FG Text}@{BG None}    PtUnsigned32   at_AssetType;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    PtUnsigned16   at_Chapter;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    PtUnsigned16   at_Count;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    PtUnsigned16   at_Lowest;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    PtUnsigned16   at_Highest;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    +       ITEMS@{BG Background}@{FG Text}
@{FG Text}@{BG None}  };@{BG Background}@{FG Text}

@{FG Text}@{BG None}  struct ASSET_TABLE_ITEM@{BG Background}@{FG Text}
@{FG Text}@{BG None}  {@{BG Background}@{FG Text}
@{FG Text}@{BG None}    PtUnsigned16   ti_Id;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    PtUnsigned16   ti_Archive;@{BG Background}@{FG Text}
@{FG Text}@{BG None}  };@{BG Background}@{FG Text}

@{FG None}@{BG None}@{u}@{i}Fields@{uu}@{ui}@{BG Background}@{FG Text}


@{FG None}@{BG None}@{u}at_Type@{uu}@{BG Background}@{FG Text}


FourCC type of the Asset

example:
  'R', 'O', 'O', 'M'


@{FG None}@{BG None}@{u}at_Chapter@{uu}@{BG Background}@{FG Text}

The Chapter that these Assets should be used in or 0 for always loaded.

example:
  1


@{FG None}@{BG None}@{u}at_Count@{uu}@{BG Background}@{FG Text}

Number of Assets in this table

example:
  10


@{FG None}@{BG None}@{u}at_Lowest@{uu}@{BG Background}@{FG Text}

The Lowest Id number in this table

example:
  1


@{FG None}@{BG None}@{u}at_Highest@{uu}@{BG Background}@{FG Text}

example:
  10


@{FG None}@{BG None}@{u}DATA@{uu}@{BG Background}@{FG Text}

An array of ASSET_TABLE_ITEMS which are immediately after the ASSET_TABLE
in memory or disk. 

There should be exactly, at_Count of them. They do not need to be zero-
terminated.

example:
  { 1, 1 }
  { 2, 1 }
  { 3, 2 }
  { 4, 2 }
  { 5, 2 }
  { 6, 3 }
  { 7, 3 }
  { 8, 3 }
  { 9, 3 }
  { 10, 4 }

@ENDNODE

@NODE DIALOGUE "Dialogue"
@{FG None}@{BG None}@{b}@{u}@{i}Dialogue@{uu}@{ub}@{ui}@{BG Background}@{FG Text}

Dialogue refers to usually anything written down, such as the following:

- Dialogue between two or more Actors in a scene
- Dialogue between an actor to the player
- Narration dialogue to the player
- Written action events
- User Interface
- Program Help Text

Dialogue is stored in tables of strings @{"String Table" LINK CT_STRING_TABLE}, it
is referenced by a 4 byte Id, which is in two parts.


@{FG Text}@{BG None}  struct DIALOGUE_REF@{BG Background}@{FG Text}
@{FG Text}@{BG None}  {@{BG Background}@{FG Text}
@{FG Text}@{BG None}    PtUnsigned16   dt_Magic;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    PtUnsigned8   dt_Table;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    PtUnsigned8   dt_Item;@{BG Background}@{FG Text}
@{FG Text}@{BG None}  };@{BG Background}@{FG Text}

@{FG Text}@{BG None}  Dialogue Text may be referred to as a Big-Endian PtUnsigned32 or as a @{BG Background}@{FG Text}
@{FG Text}@{BG None}  C DIALOGUE_REF structure.@{BG Background}@{FG Text}

@{FG None}@{BG None}@{u}@{i}As a Reference@{uu}@{ui}@{BG Background}@{FG Text}


It is recommended that common Dialogue is stored in the master archive;
0.parrot. Where as chapter or room dialogue stored in other dedicated
archives.

It should be noted, that individual pieces of dialogue cannot be sourced
from Disk, as it will bring in all of that Dialogue stored in that 
STRING_TABLE at once. So it is recommended to stored Dialogue together
based on story or location to reduce disk and memory usage.

Dialogue Ids are language neutral, as each STRING_TABLE has a ISO-639-1
code in them, so the Dialogue ID for one piece of text is the same
regardless of the language translation

It should be noted that a string may only have 255 characters, so in
some circumstances some of that string may have to be cut in length.


@{FG None}@{BG None}@{u}@{i}As a Pointer@{uu}@{ui}@{BG Background}@{FG Text}

At run-time when a Room, Entity or other type of object that has a
Dialogue Id. Once a table has been loaded, the Dialogue Id may be
turned into a pointer.


@{FG Text}@{BG None}  union DIALOGUE_TEXT@{BG Background}@{FG Text}
@{FG Text}@{BG None}  {@{BG Background}@{FG Text}
@{FG Text}@{BG None}    struct DIALOGUE_REF dt_Parts;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    PtUnsigned32               dt_AssetId;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    PtChar*               dt_Str;@{BG Background}@{FG Text}
@{FG Text}@{BG None}  };@{BG Background}@{FG Text}

@{FG None}@{BG None}@{u}@{i}Tables@{uu}@{ui}@{BG Background}@{FG Text}


There can be upto 256 tables of dialogue, consquently a total of 
65,536 lines of dialogue possible.

This may be expanded on in future versions of Parrot by reserving
some of the lower bits of dt_Magic to increase the maximum table
count.


@{FG None}@{BG None}@{u}@{i}Magic@{uu}@{ui}@{BG Background}@{FG Text}

The two magic bytes are the upper-byte of the Table and Item words
these are compile-time constants.


@{FG Text}@{BG None}  dt_Magic = 0x00FC   (As of Parrot 1.2)@{BG Background}@{FG Text}

These constants are are specially chosen to map the DIALOGUE string
pointer to an reserved address range, reserved by the Amiga 
Kickstart.


@{FG Text}@{BG None}  00FC0000@{BG Background}@{FG Text}
@{FG Text}@{BG None}  00FCFFFF            (As of Parrot 1.2)@{BG Background}@{FG Text}

Knowing that the first two bytes of start with dt_Magic it can be 
converted into a pointer with a lookup of the table and string offset 
address.

@ENDNODE

@NODE OPCODES "Opcodes"
@{FG None}@{BG None}@{b}@{u}@{i}Opcodes@{uu}@{ub}@{ui}@{BG Background}@{FG Text}
@{FG None}@{BG None}@{u}@{i}add@{uu}@{ui}@{BG Background}@{FG Text}

Pop last two values from stack and add them together. Result is in vars

Id
  0
Code
  PtSigned32 l, r;
  r = Vm_Pop(};
  l = Vm_Pop(};
  Vm_SetVar(#V, l + r};
Arg '#V'
  Name
    Var
  Type
    10-bit
  Encoding
    Bits 6-15
Arg '#L'
  Name
    LHS
  Type
    Value at Stack[0]
Arg '#R'
  Name
    RHS
  Type
    Value at Stack[-1]


@{FG None}@{BG None}@{u}@{i}adds@{uu}@{ui}@{BG Background}@{FG Text}

Pop last two values from stack and add them together. Result is in stack

Id
  1
Code
  PtSigned32 l, r;
  r = Vm_Pop(};
  l = Vm_Pop(};
  Vm_Push(l + r};
Arg '#L'
  Name
    LHS
  Type
    Value at Stack[0]
Arg '#R'
  Name
    RHS
  Type
    Value at Stack[-1]


@{FG None}@{BG None}@{u}@{i}beq@{uu}@{ui}@{BG Background}@{FG Text}

Branch to address if equals

Id
  2
Code
  if ((Vm_LastCmp & VM_CMP_EQUALS} == VM_CMP_EQUALS}
  {
    return #A;
  }
Arg '#A'
  Name
    Address
  Type
    10-bit signed
  Encoding
    Bits 6-15


@{FG None}@{BG None}@{u}@{i}bge@{uu}@{ui}@{BG Background}@{FG Text}

Branch to address if greater than or equals

Id
  3
Code
  if ((Vm_LastCmp & (VM_CMP_GT | VM_CMP_EQUALS}} != 0}
  {
    return #A;
  }
Arg '#A'
  Name
    Address
  Type
    10-bit signed
  Encoding
    Bits 6-15


@{FG None}@{BG None}@{u}@{i}bgt@{uu}@{ui}@{BG Background}@{FG Text}

Branch to address if greater than

Id
  4
Code
  if ((Vm_LastCmp & VM_CMP_GT} == VM_CMP_GT}
  {
    return #A;
  }
Arg '#A'
  Name
    Address
  Type
    10-bit signed
  Encoding
    Bits 6-15


@{FG None}@{BG None}@{u}@{i}ble@{uu}@{ui}@{BG Background}@{FG Text}

Branch to address if less than or equals

Id
  5
Code
  if ((Vm_LastCmp & (VM_CMP_LT | VM_CMP_EQUALS}} != 0}
  {
    return #A;
  }
Arg '#A'
  Name
    Address
  Type
    10-bit signed
  Encoding
    Bits 6-15


@{FG None}@{BG None}@{u}@{i}blt@{uu}@{ui}@{BG Background}@{FG Text}

Branch to address if less than

Id
  6
Code
  if ((Vm_LastCmp & VM_CMP_LT} == VM_CMP_LT}
  {
    return #A;
  }
Arg '#A'
  Name
    Address
  Type
    10-bit signed
  Encoding
    Bits 6-15


@{FG None}@{BG None}@{u}@{i}bne@{uu}@{ui}@{BG Background}@{FG Text}

Branch to address not equals

Id
  7
Code
  if ((Vm_LastCmp & VM_CMP_EQUALS} == 0}
  {
    return #A;
  }
Arg '#A'
  Name
    Address
  Type
    10-bit signed
  Encoding
    Bits 6-15


@{FG None}@{BG None}@{u}@{i}bra@{uu}@{ui}@{BG Background}@{FG Text}

Branch to address always

Id
  8
Code
  return #A;
Arg '#A'
  Name
    Address
  Type
    10-bit signed
  Encoding
    Bits 6-15


@{FG None}@{BG None}@{u}@{i}cmp@{uu}@{ui}@{BG Background}@{FG Text}

Compare variable to last item on stack

Id
  9
Code
  PtSigned32 l, r;
  r = Vm_Pop(};
  l = Vm_GetVar(#L};
  Vm_Compare(l, r};
Arg '#L'
  Name
    LHS
  Type
    10-bit
  Encoding
    Bits 6-15
Arg '#R'
  Name
    RHS
  Type
    Value at Stack[0]


@{FG None}@{BG None}@{u}@{i}cmpi@{uu}@{ui}@{BG Background}@{FG Text}

Compare variable to last item to an immediate on stack

Id
  10
Code
  PtSigned32 l, r;
  r = Vm_Pop(};
  l = #L;
  Vm_Compare(l, r};
Arg '#L'
  Name
    LHS
  Type
    10-bit
  Encoding
    Bits 6-15
Arg '#R'
  Name
    RHS
  Type
    Value at Stack[0]


@{FG None}@{BG None}@{u}@{i}cmps@{uu}@{ui}@{BG Background}@{FG Text}

Compare two stack values together

Id
  11
Code
  PtSigned32 l, r;
  r = Vm_Pop(};
  l = Vm_Pop(};
  Vm_Compare(l, r};
Arg '#L'
  Name
    LHS
  Type
    Value at Stack[0]
Arg '#R'
  Name
    RHS
  Type
    Value at Stack[-1]


@{FG None}@{BG None}@{u}@{i}dec@{uu}@{ui}@{BG Background}@{FG Text}

Decrease variable by 1

Id
  12
Code
  Vm_DecVar(#V};
Arg '#V'
  Name
    Var
  Type
    10-bit
  Encoding
    Bits 6-15


@{FG None}@{BG None}@{u}@{i}dup@{uu}@{ui}@{BG Background}@{FG Text}

Duplicate the stack value

Id
  13
Code
  Vm_Push(Vm_Peek(}};


@{FG None}@{BG None}@{u}@{i}inc@{uu}@{ui}@{BG Background}@{FG Text}

Increase variable by 1

Id
  14
Code
  Vm_IncVar(#V};
Arg '#V'
  Name
    Var
  Type
    10-bit
  Encoding
    Bits 6-15


@{FG None}@{BG None}@{u}@{i}loadi@{uu}@{ui}@{BG Background}@{FG Text}

Load a 10-bit signed value and place it onto the stack

Id
  15
Code
  Vm_Push(#V};
Arg '#V'
  Name
    Value
  Type
    10-bit
  Encoding
    Bits 6-15


@{FG None}@{BG None}@{u}@{i}loadk@{uu}@{ui}@{BG Background}@{FG Text}

Load a constant and place it onto the stack

Id
  16
Code
  PtSigned32 v;
  v = Vm_GetConstant(#C};
  Vm_Push(v};
Arg '#C'
  Name
    Constant
  Type
    10-bit
  Encoding
    Bits 6-15


@{FG None}@{BG None}@{u}@{i}mul@{uu}@{ui}@{BG Background}@{FG Text}

Pop last two values from stack and add them together. Result is in vars

Id
  17
Code
  PtSigned32 l, r;
  r = Vm_Pop(};
  l = Vm_Pop(};
  Vm_SetVar(#V, l @{b} r};@{ub}
Arg '#V'
  Name
    Var
  Type
    10-bit
  Encoding
    Bits 6-15
Arg '#L'
  Name
    LHS
  Type
    Value at Stack[0]
Arg '#R'
  Name
    RHS
  Type
    Value at Stack[-1]


@{FG None}@{BG None}@{u}@{i}pop@{uu}@{ui}@{BG Background}@{FG Text}

Pop stack value and discard

Id
  18
Code
  Vm_Pop(};


@{FG None}@{BG None}@{u}@{i}pushi@{uu}@{ui}@{BG Background}@{FG Text}

Push 10-bit signed value on the stack

Id
  19
Code
  PtSigned32 v;
  v = Vm_GetVar(#V};
  Vm_Push(v};
Arg '#V'
  Name
    Variable
  Type
    10-bit
  Encoding
    Bits 6-15


@{FG None}@{BG None}@{u}@{i}shl@{uu}@{ui}@{BG Background}@{FG Text}

Pop a value. Left Shift it and push the result on the stack

Id
  20
Code
  PtSigned32 l;
  l = Vm_Pop(};
  Vm_Push(l << #V};
Arg '#V'
  Name
    Var
  Type
    10-bit
  Encoding
    Bits 6-15
Arg '#L'
  Name
    LHS
  Type
    Value at Stack[0]


@{FG None}@{BG None}@{u}@{i}shr@{uu}@{ui}@{BG Background}@{FG Text}

Pop a value. Right Shift it and push the result on the stack

Id
  21
Code
  PtSigned32 l;
  l = Vm_Pop(};
  Vm_Push(l >> #V};
Arg '#V'
  Name
    Var
  Type
    10-bit
  Encoding
    Bits 6-15
Arg '#L'
  Name
    LHS
  Type
    Value at Stack[0]


@{FG None}@{BG None}@{u}@{i}sub@{uu}@{ui}@{BG Background}@{FG Text}

Pop last two values from stack and subtract them together. Result is in vars

Id
  22
Code
  PtSigned32 l, r;
  r = Vm_Pop(};
  l = Vm_Pop(};
  Vm_SetVar(#V, l - r};
Arg '#V'
  Name
    Var
  Type
    10-bit
  Encoding
    Bits 6-15
Arg '#L'
  Name
    LHS
  Type
    Value at Stack[0]
Arg '#R'
  Name
    RHS
  Type
    Value at Stack[-1]


@{FG None}@{BG None}@{u}@{i}subs@{uu}@{ui}@{BG Background}@{FG Text}

Pop last two values from stack and subtract them together. Result is in stack.

Id
  23
Code
  PtSigned32 l, r;
  r = Vm_Pop(};
  l = Vm_Pop(};
  Vm_Push(l - r};
Arg '#L'
  Name
    LHS
  Type
    Value at Stack[0]
Arg '#R'
  Name
    RHS
  Type
    Value at Stack[-1]


@{FG None}@{BG None}@{u}@{i}sys@{uu}@{ui}@{BG Background}@{FG Text}

Perform a System Call, where the top of the stack is the argument.

Id
  24
Code
  PtSigned32 arg;
  arg = Vm_Pop(};
  Parrot_SysCall(#F, arg};
Arg '#F'
  Name
    Function
  Type
    10-bit
  Encoding
    Bits 6-15
Arg '#A'
  Name
    Argument
  Type
    Value at Stack[0]

@ENDNODE

@NODE ROADMAP "Roadmap"
@{FG None}@{BG None}@{b}@{u}@{i}Roadmap@{uu}@{ub}@{ui}@{BG Background}@{FG Text}

Parrot is intended to be developed in the following order.

Now


@{FG Text}@{BG None}   1.0.0 Maniac Mansion (1987)@{BG Background}@{FG Text}
@{FG Text}@{BG None}         CBM Amiga Version - Lucasfilms Games@{BG Background}@{FG Text}

@{FG Text}@{BG None}   1.1.0 Data conversion@{BG Background}@{FG Text}
@{FG Text}@{BG None}         Background loading@{BG Background}@{FG Text}
@{FG Text}@{BG None}         Entity Loading@{BG Background}@{FG Text}

@{FG Text}@{BG None}   1.2.0 Large Asset Support and Design@{BG Background}@{FG Text}
@{FG Text}@{BG None}   1.3.0 Script Decompiling and Exit auto-identification.@{BG Background}@{FG Text}
@{FG Text}@{BG None}   1.4.0 Verb Support@{BG Background}@{FG Text}
@{FG Text}@{BG None}   1.5.0 Actors@{BG Background}@{FG Text}
@{FG Text}@{BG None}   1.6.0 Scripting re-visited@{BG Background}@{FG Text}
@{FG Text}@{BG None}   1.7.0 TBD@{BG Background}@{FG Text}

Future


@{FG Text}@{BG None}   2.0.0 Zak McKracken and the Alien Mindbenders (1988)@{BG Background}@{FG Text}
@{FG Text}@{BG None}         CBM Amiga Version - Lucasfilms Games@{BG Background}@{FG Text}
@{FG Text}@{BG None}   3.0.0 Indiana Jones and the Last Crusade (1989)@{BG Background}@{FG Text}
@{FG Text}@{BG None}         CBM Amiga Version - Lucasfilms Games@{BG Background}@{FG Text}
@{FG Text}@{BG None}   4.0.0 Loom (1990)@{BG Background}@{FG Text}
@{FG Text}@{BG None}         CBM Amiga Version - Lucasfilms Games@{BG Background}@{FG Text}
@{FG Text}@{BG None}   5.0.0 The Secret of Monkey Island (1990)@{BG Background}@{FG Text}
@{FG Text}@{BG None}         CBM Amiga Version - Lucasfilms Games@{BG Background}@{FG Text}
@{FG Text}@{BG None}   6.0.0 Monkey Island 2: LeChuck's Revenge (1991)@{BG Background}@{FG Text}
@{FG Text}@{BG None}         CBM Amiga Version - Lucasfilms Games@{BG Background}@{FG Text}
@{FG Text}@{BG None}   7.0.0 Indiana Jones and the Fate of Atlantis (1992)@{BG Background}@{FG Text}
@{FG Text}@{BG None}         CBM Amiga Version - Lucasfilms Games@{BG Background}@{FG Text}
@{FG Text}@{BG None}   8.0.0 Day of the Tentacle (1993)@{BG Background}@{FG Text}
@{FG Text}@{BG None}         PC DOS Version - LucasArts@{BG Background}@{FG Text}
@{FG Text}@{BG None}   9.0.0 Sam & Max Hit the Road (1993)@{BG Background}@{FG Text}
@{FG Text}@{BG None}         PC DOS Version - LucasArts@{BG Background}@{FG Text}
@{FG Text}@{BG None}  10.0.0 Full Throttle (1995)@{BG Background}@{FG Text}
@{FG Text}@{BG None}         PC DOS Version - LucasArts@{BG Background}@{FG Text}
@{FG Text}@{BG None}  11.0.9 The Dig (1995)@{BG Background}@{FG Text}
@{FG Text}@{BG None}         PC DOS Version - LucasArts@{BG Background}@{FG Text}
@{FG Text}@{BG None}  12.0.9 The Curse of Monkey Island (1997)@{BG Background}@{FG Text}
@{FG Text}@{BG None}         MS Windows Version - LucasArts@{BG Background}@{FG Text}
@ENDNODE

@NODE SQUAWK "Squawk"
@{FG None}@{BG None}@{b}@{u}@{i}Squawk@{uu}@{ub}@{ui}@{BG Background}@{FG Text}

Squawk files are Amiga IFF files that contain Game data. Usually there
are a number of Squark files that make up a Game.

As a general rule, Squark files are numbered 0 to 255 with the "parrot"
file extension.

The 0.parrot file is the master table, which contains essential game 
information, asset lookup tables, palettes, some essential scripts and
image and sound data. It is loaded at all times, and their contents 
loaded as assets within memory at game initialisation.

The 1+ parrot files typically represent a single room, with the 
necessary scripts, image, sound, entity and actor data that is 
typically in a room. This data may be loaded, or partially loaded based
on the game state.

Squawk files are also referred to as Archives within the C code.

@ENDNODE

@NODE SQUAWKLAYOUT "Squawk File Layout"
@{FG None}@{BG None}@{b}@{u}@{i}Squawk File Layout@{uu}@{ub}@{ui}@{BG Background}@{FG Text}


@{FG None}@{BG None}@{u}@{i}File Revision@{uu}@{ui}@{BG Background}@{FG Text}

Design Version
    2.0

Code Version
    1.0


@{FG None}@{BG None}@{u}@{i}General IFF Layout@{uu}@{ui}@{BG Background}@{FG Text}

LIST      SQWK
  FORM    TABL
    SLUG  Asset Table
      Asset Header
      Table Data
    SLUG  Asset Table
      Asset Header
      Table Data
    SLUG  Asset Table
      Asset Header
      Table Data
  FORM    ROOM
    SLUG  Room
      Asset Header
      Room Data
    SLUG  Room
      Asset Header
      Room Data
  FORM    SCRIPT
    SLUG  SCRIPT
      Asset Header
      Script Data
    SLUG  SCRIPT
      Asset Header
      Script Data
  ...


@{FG None}@{BG None}@{u}Slugs@{uu}@{BG Background}@{FG Text}

A slug is the asset ID encoded as a 4-byte word via the UWordToId
function, and placed within the IFF Chunk Type:-


@{FG Text}@{BG None}    PtUnsigned32   Chunk Type@{BG Background}@{FG Text}
@{FG Text}@{BG None}    PtUnsigned32   Length@{BG Background}@{FG Text}

It takes each nibble of the PtUnsigned16 and places for each byte in the
integer in little-endian order. Each byte is then added by a constant
of 0x41 to make the number compatible with FourCC. 


@{FG Text}@{BG None}    PtUnsigned32 s;@{BG Background}@{FG Text}

@{FG Text}@{BG None}    s = 0x41;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    s += (r & 0xF);@{BG Background}@{FG Text}
@{FG Text}@{BG None}    s <<= 8;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    r >>= 4;@{BG Background}@{FG Text}

@{FG Text}@{BG None}    s += 0x41;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    s += (r & 0xF);@{BG Background}@{FG Text}
@{FG Text}@{BG None}    s <<= 8;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    r >>= 4;@{BG Background}@{FG Text}

@{FG Text}@{BG None}    s += 0x41;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    s += (r & 0xF);@{BG Background}@{FG Text}
@{FG Text}@{BG None}    s <<= 8;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    r >>= 4;@{BG Background}@{FG Text}

@{FG Text}@{BG None}    s += 0x41;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    s += (r & 0xF);@{BG Background}@{FG Text}

@{FG Text}@{BG None}    return s;@{BG Background}@{FG Text}

A ID with 0, is written as AAAA, an ID with 1 is BAAA, and so on.

Although this is against the intentions of the IFF specification, 
it does not give an alternate method for searching through chunks 
without inspecting the data. As the type of data is held within 
the parent chunk, then it provides a quick and easy way of 
iteration without inspecting or knowing how the asset data is 
stored.


@{FG None}@{BG None}@{u}Asset Header@{uu}@{BG Background}@{FG Text}

The Asset Header is a four byte table placed after the IFF Chunk
Header but before any of the Asset Data.


@{FG Text}@{BG None}  struct ASSET_HEADER@{BG Background}@{FG Text}
@{FG Text}@{BG None}  {@{BG Background}@{FG Text}
@{FG Text}@{BG None}    PtUnsigned16 ah_Id;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    PtUnsigned16 ah_AssetFlags;@{BG Background}@{FG Text}
@{FG Text}@{BG None}  };@{BG Background}@{FG Text}

@{FG None}@{BG None}Asset Id@{BG Background}@{FG Text}


The Id is a PtUnsigned16 start starts from 1 to 65535. This is a repeat
of the Slug in the Chunk Type, but in its original form.


@{FG None}@{BG None}Asset Flags@{BG Background}@{FG Text}

ah_AssetFlags are populated by the CHUNK_FLAGS enum, these can be 
the following values:

Bit 0:  Asset is for the ECS Arch
Bit 1:  Asset is for the AGA Arch
Bit 2:  Asset is for the RTS Arch
Bit 13: Asset may be larger than the Chunk Type specifies, this may be
        due to a sub-type like Entities, or it has dynamic data - such
        as a Script.
Bit 14: Asset has some extra data appended at the end of the asset 
        which requires a special function to load and unload the data.
        This is specified by the CHUNK_FACTORY of that type. Not to be
        confused with Bit 13.
Bit 15: This asset should be ignored and not loaded.

Note:

Bits 0,1,2 May be OR'd together to represent that the asset can be
           loaded regardless of architecture, and this is recommended
           practise for assets that are not backdrops, images or audio
           data.


@{FG None}@{BG None}@{u}Asset Data@{uu}@{BG Background}@{FG Text}

The Data is stored after the Asset Header. These may be:

- @{"Game Info" LINK ct_gameinfo}
- @{"Table" LINK ct_table}

@ENDNODE

@NODE TERMINOLOGY "Terminology"
@{FG None}@{BG None}@{b}@{u}@{i}Terminology@{uu}@{ub}@{ui}@{BG Background}@{FG Text}


@{FG None}@{BG None}@{u}@{i}A@{uu}@{ui}@{BG Background}@{FG Text}


@{FG None}@{BG None}@{u}Actor@{uu}@{BG Background}@{FG Text}

A Person, Robot, Electronic Device or otherwise movable or immovable 
interactive character that is part of the story.

See @{"Actor (Asset}](CT_ACTOR}, Asset


@{FG None}@{BG None}@{u}Asset@{uu}@{BG Background}@{FG Text}

A saved resource, such as GameInfo, Tables, Room, Actors, Backdrops.

See Actor, Backdrop,


@{FG None}@{BG None}@{u}@{i}B@{uu}@{ui}@{BG Background}@{FG Text}


@{FG None}@{BG None}@{u}Backdrop@{uu}@{BG Background}@{FG Text}

A image that is shown last during a Room. It is non-interactive,
and can be bigger than the display size.


@{FG None}@{BG None}@{u}@{i}C@{uu}@{ui}@{BG Background}@{FG Text}


@{FG None}@{BG None}@{u}@{i}Chapter@{uu}@{ui}@{BG Background}@{FG Text}

A collection of assets; rooms, scripts, actors, images, sounds, etc.
which make up a fragment of an entire story. The only exception is
the global chapter "0" where assets are always available and shared
between other chapters.

Chapters are numbered from 0 to 255.


@{FG None}@{BG None}@{u}@{i}G@{uu}@{ui}@{BG Background}@{FG Text}


@{FG None}@{BG None}@{u}Game Info@{uu}@{BG Background}@{FG Text}

A asset containing the initialisation and meta data about a Game.

See @{"GameInfo (Asset}](CT_GAMEINFO}, Asset

@ENDNODE

@NODE TYPENOTATION "Type Notation"
@{FG None}@{BG None}@{b}@{u}@{i}Type Notation@{uu}@{ub}@{ui}@{BG Background}@{FG Text}


@{FG None}@{BG None}@{u}@{i}Names@{uu}@{ui}@{BG Background}@{FG Text}

Byte
  8 bit unsigned integer
Character, Char
  8 bit unsigned integer representing a single text ASCII character.
Word, Short
  16 bit signed integer
UWord, UShort
  16 bit unsigned integer
Long, Int
  32 bit signed integer
ULong, UInt
  32 bit unsigned integer
APtr
  32 bit untyped pointer
Asset Type
  4 byte non-null terminating string indicating the type of asset 
  data. Usually expressed as as a ulong.
Asset Id
  2 byte identifier. used with asset type and arch flags to 
  identify an asset.
Chunk Header
  4 byte struct containing the id of an asset, and specific 
  loading flags
Asset Header
  8 byte struct containing the Asset Type and Chunk header
Language Id
  4 byte identifier where bits 16-24 represent the Room ID, and 
  the lower 16-bits represents the language text id. Language text 
  may be used for dialogue, textual form of events, verb construction
  or user interface labels. Bits 24-32 arent used.


@{FG None}@{BG None}@{u}@{i}Suffixes@{uu}@{ui}@{BG Background}@{FG Text}

.b
  Byte
.sb
  Signed Byte
.w
  Word
.l
  Long
.lb
  Lower nibble of a byte
.hb
  Higher nibble of a byte
.sp
  Signed pointer offset to Script Program Counter. Value is always 
  multiplied by 2 when used.
.a
  Typeless/arch-less asset id - 2 bytes
.r
  Asset Header
.x
  1 byte Padding Unused
.d
  Language Id

@ENDNODE

@NODE VERSION "Parrot Version"
@{FG None}@{BG None}@{b}@{u}@{i}Parrot Version@{uu}@{ub}@{ui}@{BG Background}@{FG Text}

Parrot uses the sematic versioning system where a given 
version number is written as:


@{FG Text}@{BG None}  GAME.FEATURE.BUILD@{BG Background}@{FG Text}


GAME versions correspond to which minimum Game Parrot
supports, these are:-


@{FG Text}@{BG None}   1. Maniac Mansion (1987)@{BG Background}@{FG Text}
@{FG Text}@{BG None}      CBM Amiga Version - Lucasfilms Games@{BG Background}@{FG Text}
@{FG Text}@{BG None}   2. Zak McKracken and the Alien Mindbenders (1988)@{BG Background}@{FG Text}
@{FG Text}@{BG None}      CBM Amiga Version - Lucasfilms Games@{BG Background}@{FG Text}
@{FG Text}@{BG None}   3. Indiana Jones and the Last Crusade (1989)@{BG Background}@{FG Text}
@{FG Text}@{BG None}      CBM Amiga Version - Lucasfilms Games@{BG Background}@{FG Text}
@{FG Text}@{BG None}   4. Loom (1990)@{BG Background}@{FG Text}
@{FG Text}@{BG None}      CBM Amiga Version - Lucasfilms Games@{BG Background}@{FG Text}
@{FG Text}@{BG None}   5. The Secret of Monkey Island (1990)@{BG Background}@{FG Text}
@{FG Text}@{BG None}      CBM Amiga Version - Lucasfilms Games@{BG Background}@{FG Text}
@{FG Text}@{BG None}   6. Monkey Island 2: LeChuck's Revenge (1991)@{BG Background}@{FG Text}
@{FG Text}@{BG None}      CBM Amiga Version - Lucasfilms Games@{BG Background}@{FG Text}
@{FG Text}@{BG None}   7. Indiana Jones and the Fate of Atlantis (1992)@{BG Background}@{FG Text}
@{FG Text}@{BG None}      CBM Amiga Version - Lucasfilms Games@{BG Background}@{FG Text}
@{FG Text}@{BG None}   8. Day of the Tentacle (1993)@{BG Background}@{FG Text}
@{FG Text}@{BG None}      PC DOS Version - LucasArts@{BG Background}@{FG Text}
@{FG Text}@{BG None}   9. Sam & Max Hit the Road (1993)@{BG Background}@{FG Text}
@{FG Text}@{BG None}      PC DOS Version - LucasArts@{BG Background}@{FG Text}
@{FG Text}@{BG None}  10. Full Throttle (1995)@{BG Background}@{FG Text}
@{FG Text}@{BG None}      PC DOS Version - LucasArts@{BG Background}@{FG Text}
@{FG Text}@{BG None}  11. The Dig (1995)@{BG Background}@{FG Text}
@{FG Text}@{BG None}      PC DOS Version - LucasArts@{BG Background}@{FG Text}
@{FG Text}@{BG None}  12. The Curse of Monkey Island (1997)@{BG Background}@{FG Text}
@{FG Text}@{BG None}      MS Windows Version - LucasArts@{BG Background}@{FG Text}

Files saved via older GAME versions are expected 
to be incompatible with newer GAME versions.


@{FG Text}@{BG None}  i.e.  Parrot files saved with version 3.9.3 are@{BG Background}@{FG Text}
@{FG Text}@{BG None}        likely not to work with with Parrot 2.0.1@{BG Background}@{FG Text}

@{FG Text}@{BG None}        However; Parrot 3.9.3, can play Maniac Mansion,@{BG Background}@{FG Text}
@{FG Text}@{BG None}        Zak McKracken and the Alien MindBenders and@{BG Background}@{FG Text}
@{FG Text}@{BG None}        Indiana Jones and the Last Crusade.@{BG Background}@{FG Text}

FEATURE versions are incremented when a feature of
that Game has been totally completed. This is expected
to have backwards compatbile manner.

BUILD versions are incremented when a commit has been
pushed to the Git and Github repository. Although a 
1:1 parity is not expected. BUILD versions are stored
as a two byte integer, and can roll over if the number
of commits reaches 65,535.


@{FG None}@{BG None}@{u}@{i}C Implementation@{uu}@{ui}@{BG Background}@{FG Text}

Internally a VERSION_INFO union is used which is represents
a version number as a C Struct or a PtUnsigned32 (in Big Endian}


@{FG Text}@{BG None}  union VERSION_INFO@{BG Background}@{FG Text}
@{FG Text}@{BG None}  {@{BG Background}@{FG Text}
@{FG Text}@{BG None}    struct@{BG Background}@{FG Text}
@{FG Text}@{BG None}    {@{BG Background}@{FG Text}
@{FG Text}@{BG None}      PtUnsigned8 gv_Game;@{BG Background}@{FG Text}
@{FG Text}@{BG None}      PtUnsigned8 gv_Feature;@{BG Background}@{FG Text}
@{FG Text}@{BG None}      PtUnsigned8 gv_Build;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    } gv_Version;@{BG Background}@{FG Text}
@{FG Text}@{BG None}    PtUnsigned32 gv_Num;@{BG Background}@{FG Text}
@{FG Text}@{BG None}  };@{BG Background}@{FG Text}

To determine if a a Version is older or newer, the gv_Num field
can be compared with <, > or == operators.

@ENDNODE

@NODE VM "Virtual Machine"
@{FG None}@{BG None}@{b}@{u}@{i}VM@{uu}@{ub}@{ui}@{BG Background}@{FG Text}

Stack based virtual machine. Each stack variable is 4 bytes (PtSigned32}.
There are 16 variables and 256 global variables.

Variables may belong to the object or room running with the script.

@ENDNODE
d 256 global variables.

Variables may belong to the object or room running with the script.

@ENDNODE
long to the object or room running with the script.

@ENDNODE
